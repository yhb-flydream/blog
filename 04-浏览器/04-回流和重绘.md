# 回流和重绘

> **参考**
>
> [《浏览器的回流与重绘 (Reflow & Repaint)》(作者：腰花)【来源：掘金】](https://juejin.im/post/5a9923e9518825558251c96a)
>
> [《什么是回流，什么是重绘，有什么区别？》(作者：你滴止痛药儿)【来源：简书】](https://www.jianshu.com/p/e081f9aa03fb)
>
> [《第 22 题：介绍下重绘和回流（Repaint & Reflow），以及如何进行优化》(作者：Advanced-Frontend)【来源：github】](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)

[TOC]

**回流必将引起重绘，重绘不一定会引起回流。**

## reflow（回流）

当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，称这个回退的过程叫 reflow（回流）。

- reflow 会从 `<html>` 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。
- reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。
- 鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。
- 通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

### 引起回流的操作

任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流。

- 页面首次渲染
- 浏览器窗口尺寸改变——resize 事件发生时
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在 input 框中输入文字
- 元素字体大小变化
- 添加或者删除可见的 DOM 元素
- 计算 offsetWidth 和 offsetHeight 属性
- 设置 style 属性的值
- 激活 CSS 伪类（例如：:hover）

> width、height
> margin、padding、position
> display、overflow
> border
> clientWidth、clientHeight、clientTop、clientLeft
> offsetWidth、offsetHeight、offsetTop、offsetLeft
> scrollWidth、scrollHeight、scrollTop、scrollLeft
> scrollIntoView()、scrollIntoViewIfNeeded()
> getComputedStyle()、getBoundingClientRect()
> scrollTo()

## repaint（重绘）

改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

**注意：**

1. `display:none` 的节点不会被加入 Render Tree，而`visibility: hidden` 则会，所以，如果某个节点最开始是不显示的，设为`display:none`是更优的。
2. `display:none` 会触发 reflow，而 `visibility:hidden` 只会触发 repaint，因为没有发现位置变化。
3. 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

### 常见引起重绘属性和方法

> color
> border-style、border-radius
> box-shadow
> visibility
> text-decoration
> background、background-image、background-position、background-repeat、background-size
> outline、outline-color、outline-style、outline-width

## 减少 reflow/repaint

- 使用 transform 替代 top
- 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
- 把 DOM 离线后修改。
  - 使用 documentFragment 对象在内存里操作 DOM
  - 先把 DOM 给`display:none`(有一次 reflow)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。
  - clone 一个 DOM 结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。
- 尽可能的修改层级比较低的 DOM。当然，改变层级比较底的 DOM 有可能会造成大面积的 reflow，但是也可能影响范围很小。
- 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame

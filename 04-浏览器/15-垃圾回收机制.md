# 垃圾回收机制

> **参考**
>
> [《JavaScript 垃圾回收机制》(作者：郑文亮)【来源：博客园】](https://www.cnblogs.com/zhwl/p/4664604.html)
>
> [《前端面试：谈谈 JS 垃圾回收机制》(作者：前端小智)【来源：思否】](https://segmentfault.com/a/1190000018605776)
>
> [《浏览器垃圾回收机制与 Vue 项目内存泄漏分析》(作者：SHERlocked93)【来源：掘金】](https://juejin.cn/post/6844903938756460558)
>
> [《浏览器垃圾回收机制》(作者：左手 121)【来源：CSDN】](https://blog.csdn.net/qq_20282263/article/details/88694143)
>
> [《浅谈 V8 引擎中的垃圾回收机制》(作者：天镶)【来源：掘金】](https://segmentfault.com/a/1190000000440270)
>
> [《V8 之旅： 垃圾回收器》(作者：liuyanghejerry)【来源：NewHTML】](http://newhtml.net/v8-garbage-collection/)
>
> [《「硬核 JS」你真的了解垃圾回收机制吗》(作者：isboyjc)【来源：掘金】](https://juejin.cn/post/6981588276356317214)

[TOC]

## 堆的构成

在我们深入研究垃圾回收器的内部工作原理之前，首先来看看堆是如何组织的。V8 将堆分为了几个不同的区域：

- **新生区**：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。
- **老生指针区**：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。
- **老生数据区**：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。
- **大对象区**：这里存放体积超越其他区大小的对象。每个对象有自己 map 产生的内存。垃圾回收器从不移动大对象。
- **代码区**：代码对象，也就是包含 JIT 之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。_译注：但是大对象内存区本身不是可执行的内存区_）。
- **Cell 区、属性 Cell 区、Map 区**：这些区域存放 Cell、属性 Cell 和 Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。

## 什么是垃圾回收机制

由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

## 为什么要进行垃圾回收

V8 的内存限制：

- 表层原因是 V8 最初为浏览器设计，不太可能会遇到使用大量内存的场景。
- 深层原因是 V8 垃圾回收机制的限制。

> 根据官方说法，对于 1.5G 的垃圾回收堆内存，V8 做一次小的垃圾回收需要 50ms，做一次非增量式的垃圾回收在 1s 以上（小垃圾回收和非增量都是垃圾回收策略，后续后讲到）。这些是垃圾回收引起 js 执行暂停的时间。在这样的时间花销下，前后端都是没法接受的，因此直接限制堆内存是一个合理的选择。

调整内存限制：

node 在启动时可以传递参数来调整限制内存大小：

- `node --max-old-space-size=1700` // 单位是 MB
- `node --max_semi_space_size=1024` // 单位是 KB

## 浏览器实现垃圾回收的方法

- 分代回收

### 分代回收

脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8 将堆进行了分代。

对象起初会被分配在新生区（通常很小，只有 1-8 MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。**对于活跃超过 2 个小周期的对象，则需将其移动至老生区。**

老生区在**标记－清除**或**标记－紧缩**（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。

#### 新生区

由于清理发生的很频繁，清理必须进行的非常快速。V8 中的清理过程称为 `Scavenge` 算法，是按照 `Cheney` 的算法实现的。

这个算法大致是，新生区被划分为两个等大的子区：**出区、入区**。

绝大多数内存的分配都会在出区发生（但某些特定类型的对象，如可执行的代码对象是分配在老生区的），当出区耗尽时，我们交换出区和入区（这样所有的对象都归属在入区当中），然后将入区中活跃的对象复制至出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升 Cache 的内存局部性，保持内存分配的简洁快速。

移动至老生区有两种情况下：

- 对象是否经历过 Scavenge 回收
- 入区空间的内存占用超过 25% 限制

#### 老生区

Scavenge 算法对于快速回收、紧缩小片内存效果很好，但对于大片内存则消耗过大。因为 Scavenge 算法需要出区和入区两个区域，这对于小片内存尚可，而对于超过数百 MB 的内存就开始变得不切实际了。老生区包含有上百 MB 的数据，对于这么大的区域，我们采取另外两种相互较为接近的算法：“**标记－清除**”算法与“**标记－紧缩**”算法。

这两种算法都包括两个阶段：

- 标记阶段
- 清除或紧缩阶段

##### 标记－清除

- 标记阶段：对老生区进行第一次扫描，标记活动对象
- 清理阶段：对老生区进行第二次扫描，清除未被标记的对象，即清理非活动对象

标记－清除虽然清理的非活动对象，释放了内存空间，但是产生了很多内存碎片，对再分配大块内存很不利。

##### 标记－紧缩

标记－紧缩是在标记－清理基础上演进而来，它在清理完非活动对象释放内存空间之后，会把所有的活动对象向一端移动，可以释放出大块的内存，以备之后堆内存的合理分配。

##### 两者结合

由于标记 - 紧缩算法需要移动对象，因此它的速度不会很快，V8 结合了标记 - 清除和标记 - 紧缩算法，主要采用标记 - 清除算法，如果空间不足的时候，才使用标记 - 紧缩进行整理。

## V8 垃圾回收的优化策略

### 全停顿（Stop-The-World）

最初，为了避免 js 逻辑和垃圾回收器看到的情况不一致的问题，V8 采用了垃圾回收时将 js 执行暂停下来的方式，等待垃圾回收结束后才恢复 js 的执行，这种行为被成为全停顿（Stop-The-World）。

这种方式的劣势明显，它会阻塞 js 的执行，如果垃圾回收占用的时间较长，就会造成页面明显的卡顿。为了解决全停顿的问题，V8 添加**并行**、**增量**、**并发**等技术对垃圾回收机制进行了优化。

新生代中副垃圾回收器采用的就是并行方式，它在主线程执行垃圾回收的过程中，启动了多个辅助线程来负责垃圾清理操作，这些辅助线程同时将 From 空间中的数据移动到 To 区域。但本质上并行方式还是一种"全停顿"，因此还不能满足对性能要求更高的老生代垃圾回收。

### 并行回收（Parallel）

并行方式是主线程在执行垃圾回收的任务的同时，使用多个辅助线程来并行处理，这样就会加快垃圾回收的执行速度。

在标记阶段，所有堆上的活跃对象都会被标记。每个页都会包含一个用来标记的位图，位图中的每一位对应页中的一字（_译注：一个指针就是一字大小_）。这个标记非常有必要，因为指针可能会在任何字对齐的地方出现。显然，这样的位图要占据一定的空间（32 位系统上占据 3.1%，64 位系统上占据 1.6%），但所有的内存管理机制都需要这样占用，因此这种做法并不过分。除此之外，另有 2 位来表示标记对象的状态。由于对象至少有 2 字长，因此这些位不会重叠。

### 增量回收 （Incremental）

2011 年，V8 从又引入了增量回收 （Incremental）的方式。垃圾回收器不需要一次执行完整的垃圾回收过程，每次只执行整个垃圾回收过程中的一小部分工作，比如每次标记一部分数据。主线程中，js 和垃圾回收交替执行，可以避免单次垃圾回收时间过长造成的卡顿问题。

增量回收 （Incremental）会带来两个问题：

- 垃圾回收和 js 切换执行，暂停垃圾回收时需要保存当时的标记结果，切换回来之后需要知道从哪个位置继续执行
- 切换到 js 执行后，js 代码的执行可能会修改之前已经标记好的数据，造成影响

针对上面的两个问题，V8 引入了 **三色标记法** 和 **写屏障机制（Write-barrier）** 来解决。

#### 三色标记法

为了解决增量回收中垃圾回收恢复执行时不知道从哪个位置继续开始执行的问题，V8 采用黑、白、灰三色标记法。

- 白色表示这个节点没有被访问到，如果在本轮垃圾回收结束时还是白色，那么这块数据就会被收回。初始阶段，所有节点都是白色。
- 如果一个对象的状态为灰，那么它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕；
- 如果一个对象的状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕。

垃圾回收器可以根据当前是否存在灰色节点来判断整个标记是否完成。如果没有灰色节点了，就可以清理掉白色节点了。如果还有灰色标记，当再次恢复垃圾回收时，便从灰色的节点开始继续执行。

#### 写屏障机制（Write-barrier）

#### 并发回收 （Concurrent）

并发是指主线程不断执行 js 代码，而辅助线程则在后台完全执行垃圾回收。

并发回收主要有以下两个问题：

- 当主线程执行 js 代码时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效
- 主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能

#### 三种方式组合

并行、增量、并发三种方式在 V8 的实际应用中不是单独存在的，V8 的主垃圾回收器融合了这三种机制。

- 主垃圾回收器主要使用并发标记，在主线程执行 js 时，辅助线程就开始执行标记任务了，所以说标记是在辅助线程中完成的
- 标记完成后，开始执行并行清理。主线程在执行清理操作时，多个辅助线程也在执行清理操作。
- 主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 js 代码执行之间

## 优化垃圾回收

### 对象 object 优化

为了最大限度的实现对象的重用，应该像避使用 new 语句一样避免使用{}来新建对象。

### 数组 array 优化

### 方法 function 优化

## 导致内存泄漏的操作

### 意外的全局变量

### 闭包

### 没有清理的 DOM 元素

### 被遗忘的定时器或者回调

### 子元素存在引用引起的内存泄露

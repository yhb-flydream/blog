# 垃圾回收机制

> **参考**
>
> [《JavaScript 垃圾回收机制》(作者：郑文亮)【来源：博客园】](https://www.cnblogs.com/zhwl/p/4664604.html)
>
> [《前端面试：谈谈 JS 垃圾回收机制》(作者：前端小智)【来源：思否】](https://segmentfault.com/a/1190000018605776)
>
> [《浏览器垃圾回收机制与 Vue 项目内存泄漏分析》(作者：SHERlocked93)【来源：掘金】](https://juejin.cn/post/6844903938756460558)
>
> [《浏览器垃圾回收机制》(作者：左手 121)【来源：CSDN】](https://blog.csdn.net/qq_20282263/article/details/88694143)

[TOC]

## 什么是垃圾回收机制

由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

## 为什么要进行垃圾回收

V8 的内存限制：

- 表层原因是 V8 最初为浏览器设计，不太可能会遇到使用大量内存的场景。
- 深层原因是 V8 垃圾回收机制的限制。

> 根据官方说法，对于 1.5G 的垃圾回收堆内存，V8 做一次小的垃圾回收需要 50ms，做一次非增量式的垃圾回收在 1s 以上（小垃圾回收和非增量都是垃圾回收策略，后续后讲到）。这些是垃圾回收引起 js 执行暂停的时间。在这样的时间花销下，前后端都是没法接受的，因此直接限制堆内存是一个合理的选择。

调整内存限制：

node 在启动时可以传递参数来调整限制内存大小：

- `node --max-old-space-size=1700` // 单位是 MB
- `node --max_semi_space_size=1024` // 单位是 KB

## 浏览器实现垃圾回收的方法

在 JavaScript 中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收。为了提高回收效率，V8 将堆分为两类**新生代**和**老生代**，**新生代中存放的是生存时间短的对象**，**老生代中存放的生存时间久的对象**。

新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。
- 主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收。

### 新生代

### 老生代

### 标记清除（目前常用方式）

**当变量进入环境时，将变量标记"进入执行环境"；当变量离开环境时，标记为：“离开执行环境”。**

某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。

### 引用计数

> 跟踪记录每个 **值** 被引用的次数。

当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将这个值所占的内存空间给收回来。

因为存在循环引用的情况会导致内存无法释放，需要手动值为 null。

## 什么时候触发垃圾回收

一般浏览器会自动触发 GC。但是和其他语言一样，当触发 GC 的时候，浏览器就会停止工作。如果频繁触发 GC 页面就会发生抖动现象。

一般的 GC 耗时在 100ms 左右，对于一般的程序来说够了。但是对于一些流畅度要求高的程序来说就很麻烦，这就需要新引擎需要优化的地方。

### GC 优化

1. 分代回收（Generation GC）
   - 这个和 Java 回收策略思想是一致的，也是 V8 所主要采用的。
   - 目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。
2. 增量 GC
   - 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。

## 优化垃圾回收

### 对象 object 优化

为了最大限度的实现对象的重用，应该像避使用 new 语句一样避免使用{}来新建对象。

### 数组 array 优化

### 方法 function 优化

## 导致内存泄漏的操作

### 意外的全局变量

### 闭包

### 没有清理的 DOM 元素

### 被遗忘的定时器或者回调

### 子元素存在引用引起的内存泄露

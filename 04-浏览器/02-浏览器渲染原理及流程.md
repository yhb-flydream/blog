# 浏览器渲染原理及流程

> **参考**
>
> [《深入浅出浏览器渲染原理》(作者：Fundebug)【来源：知乎】](https://zhuanlan.zhihu.com/p/53913989)
>
> [《浏览器渲染原理及流程》(作者：李某龙)【来源：博客园】](https://www.cnblogs.com/slly/p/6640761.html)
>
> [《浏览器渲染原理与过程》(作者：oWSQo)【来源：简书】](https://www.jianshu.com/p/e6252dc9be32)
>
> [《浏览器的渲染：过程与原理》(作者：天方夜)【来源：知乎】](https://zhuanlan.zhihu.com/p/29418126)
>
> [《浏览器渲染原理及流程》(作者：huzhao0316)【来源：github】](https://github.com/huzhao0316/articals/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B)
>
> [《从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机》(作者：杨敬卓)【来源：github】](https://github.com/aooy/blog/issues/5)
>
> [《你不知道的浏览器页面渲染机制》(作者：浪里行舟)【来源：掘金】](https://juejin.cn/post/6844903815758479374)
>
> [《从 Chrome 源码看浏览器如何构建 DOM 树》(作者：会编程的银猪)【来源：人人 FED】](https://www.rrfed.com/2017/01/30/chrome-build-dom/)
>
> [《从 Chrome 源码看浏览器的事件机制》(作者：会编程的银猪)【来源：人人 FED】](https://www.rrfed.com/2017/02/05/browser-event/)
>
> [《从 Chrome 源码看浏览器如何计算 CSS》(作者：会编程的银猪)【来源：人人 FED】](https://www.rrfed.com/2017/02/22/chrome-css/)
>
> [《从 Chrome 源码看浏览器如何 layout 布局》(作者：会编程的银猪)【来源：人人 FED】](https://www.rrfed.com/2017/02/26/chrome-layout/)

[TOC]

浏览器内核分为两部分：渲染引擎和 JS 引擎。

## 渲染引擎

- Firefox 使用 gecko —— Mozilla 自主研发的渲染引擎
- Safari 和 Chrome 都使用 webkit

## 浏览器渲染流程

渲染引擎在取得内容之后的基本流程：

1. **构建 DOM 树**： 处理 HTML 标记并构建 DOM 树；
2. **构建 CSS Rule Tree 树**： 处理 CSS 标记并构建 CSS Rule Tree 树；
3. **合并为渲染树**： 将 DOM 与 CSS Rule Tree 合并成一个渲染树；
4. **布局**： 根据渲染树来布局，以计算每个节点的几何信息；
5. **绘制**： 将各个节点绘制到屏幕上。

### 构建 DOM 树

浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树：

```text
字节数据 => 字符串 => Token => Node => DOM
```

### 构建 CSS Rule 树

CSS 标注了 DOM 会如何展示，构建 CSSOM 的过程与构建 DOM 的过程非常相似，当浏览器接收到一段 CSS，浏览器首先要做的是识别出 Token，然后构建节点并生成 CSSOM。

> 注意：CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情。所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去。

### 构建渲染树

生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

**渲染树只包含可见的节点。**

在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

不可见的节点包括：

- 一些不会渲染输出的节点，比如 script、meta、link 等；
- 一些通过 css 进行隐藏的节点，比如 display:none。

> 注意，利用 visibility 和 opacity 隐藏的节点，还是会显示在渲染树上的。只有 display:none 的节点才不会显示在渲染树上。

### 布局

布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个 Render Object 对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

### 渲染

布局完成之后浏览器就会将渲染树绘制到屏幕上。

## reflow（回流）

当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，称这个回退的过程叫 reflow（回流）。

- reflow 会从 `<html>` 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。
- reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。
- 鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。
- 通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

### 引起回流的方法或操作

任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流。

- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在 input 框中输入文字
- 浏览器窗口尺寸改变——resize 事件发生时
- 计算 offsetWidth 和 offsetHeight 属性
- 设置 style 属性的值

> width、height、margin、padding、display、border、position、overflow、clientWidth、clientHeight、clientTop、clientLeft、offsetWidth、offsetHeight、offsetTop、offsetLeft、scrollWidth、scrollHeight、scrollTop、scrollLeft、scrollIntoView()、scrollTo()、getComputedStyle()、getBoundingClientRect()、scrollIntoViewIfNeeded()

## repaint（重绘）

改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

**注意：**

1. `display:none` 的节点不会被加入 Render Tree，而`visibility: hidden` 则会，所以，如果某个节点最开始是不显示的，设为`display:none`是更优的。
2. `display:none` 会触发 reflow，而 `visibility:hidden` 只会触发 repaint，因为没有发现位置变化。
3. 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

### 常见引起重绘属性和方法

> color、border-style、visibility、text-decoration、background、background-image、background-position、background-repeat、background-size、outline-color、outline、outline-style、outline-width、border-radius、box-shadow

### 减少 reflow/repaint

- 使用 transform 替代 top
- 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
- 把 DOM 离线后修改。
  - 使用 documentFragment 对象在内存里操作 DOM
  - 先把 DOM 给`display:none`(有一次 reflow)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。
  - clone 一个 DOM 结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。
- 尽可能的修改层级比较低的 DOM。当然，改变层级比较底的 DOM 有可能会造成大面积的 reflow，但是也可能影响范围很小。
- 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame

## 阻塞渲染

谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

同时，由于下面两点：

- 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSS Rule Tree 构建完毕。
- JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSS Rule Tree 属性。

存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：

- 当浏览器遇到一个 `<script>` 标记时，DOM 构建将暂停，直至脚本完成执行。
- JavaScript 可以查询和修改 DOM 与 CSS Rule Tree。
- CSS Rule Tree 构建时，JavaScript 执行将暂停，直至 CSS Rule Tree 就绪。

所以，`<script>` 标签的位置很重要。实际使用时，可以遵循下面两个原则：

- CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
- JavaScript 应尽量少影响 DOM 的构建（将`<script>` 标签放在 `</body>` 前面）。

### 改变阻塞模式：defer 与 async

为什么要将 script 加载的 defer 与 async 方式放到后面呢？因为这两种方式是的出现，全是由于前面讲的那些阻塞条件的存在。换句话说，defer 与 async 方式可以改变之前的那些阻塞情形。

首先，注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。

```js
// 按照从上到下的顺序输出 1 2 3
<script async>
  console.log("1");
</script>
<script defer>
  console.log("2");
</script>
<script>
  console.log("3");
</script>
```

故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。

#### defer

```js
<script src="app1.js" defer></script>
<script src="app2.js" defer></script>
<script src="app3.js" defer></script>
```

**defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的**。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：

- 载入 JavaScript 文件时不阻塞 HTML 的解析
- 执行阶段被放到 HTML 标签解析完成之后

#### async

```js
<script src="app.js" async></script>
<script src="ad.js" async></script>
<script src="statistics.js" async></script>
```

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。多个 async-script 的执行顺序是不确定的。

# 浏览器输入 URL 后发生了什么

> **参考**
>
> [《浏览器中输入 url 后发生了什么》(作者：Dreammin_chen)【来源：简书】](https://www.jianshu.com/p/c1dfc6caa520)
>
> [《经典面试题：在浏览器地址栏输入一个 URL 后回车，背后发生了什么》(作者：飞天小牛肉)【来源：腾讯云社区】](https://cloud.tencent.com/developer/article/1793846)
>
> [《关于 TCP 三次握手和四次挥手，满分回答在此》(作者：飞天小牛肉)【来源：飞天小牛肉】](https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&mid=2247484021&idx=1&sn=62ecef5d4b08b542056f2f614f5fb4b6&scene=21#wechat_redirect)
>
> [《浏览器输入 URL 后发生了什么？》(作者：Chikara Chan)【来源：知乎】](https://zhuanlan.zhihu.com/p/43369093)
>
> [《在浏览器输入 URL 回车之后发生了什么（超详细版）》(作者：4Ark)【来源：掘金】](https://juejin.im/post/5d5e795ff265da03e275f29e)
>
> [《细说浏览器输入 URL 后发生了什么》(作者：winty)【来源：掘金】](https://juejin.im/post/5e32449d6fb9a02fe4581907)
>
> [《细说浏览器输入 URL 后发生了什么》(作者：自由之鹰)【来源：思否】](https://segmentfault.com/a/1190000012092552)
>
> [《(1.6w 字)浏览器灵魂之问，请问你能接得住几个？ - 第 3 篇: 说一说从输入 URL 到页面呈现发生了什么？——网络篇》(作者：神三元)【来源：掘金】](https://juejin.cn/post/6844904021308735502#heading-24)
>
> [《(1.6w 字)浏览器灵魂之问，请问你能接得住几个？ - 第 4 篇: 说一说从输入 URL 到页面呈现发生了什么？——解析算法篇》(作者：神三元)【来源：掘金】](https://juejin.cn/post/6844904021308735502#heading-33)
>
> [《(1.6w 字)浏览器灵魂之问，请问你能接得住几个？ - 第 5 篇: 说一说从输入 URL 到页面呈现发生了什么？——渲染过程篇》(作者：神三元)【来源：掘金】](https://juejin.cn/post/6844904021308735502#heading-46)
>
> [《从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！》(作者：撒网要见鱼)【来源：CSDN】](https://www.cnblogs.com/dailc/p/8547384.html)
>
> [《从输入 URL 到页面加载完成的过程中都发生了什么事情？》(作者：nwind)【来源：FEX】](http://fex.baidu.com/blog/2014/05/what-happen/)
>
> [《史上最详细的经典面试题 从输入 URL 到看到页面发生了什么？》(作者：虚竹子)【来源：掘金】](https://juejin.cn/post/6844903832435032072)
>
> [《从输入 URL 开始建立前端知识体系》(作者：FinGet)【来源：掘金】](https://juejin.cn/post/6935232082482298911)

[TOC]

从浏览器输入一个地址，敲回车以后，到页面加载完成，浏览器经历了哪些步骤呢？

1. URL 解析
2. 查询缓存
3. DNS 域名解析
4. 建立 TCP 连接(三次握手)
5. 发送 HTTP 请求
6. 服务器处理请求
7. 返回响应结果
8. 关闭 TCP 连接(四次挥手)
9. 浏览器解析 HTML 并渲染

## URL 解析

- **目的**：处理输入到地址栏中的内容，进行不同的处理
- **地址解析**：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。
- **HSTS**：由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。_关于 HSTS [你所不知道的 HSTS](https://www.barretlee.com/blog/2015/10/22/hsts-intro/)_
- **其他操作**：浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。
- **检查缓存**：![检查缓存](https://i.loli.net/2020/05/14/t8oT34agwx1B29j.png)

## 查询缓存

[缓存](./04-缓存.md)

判断当前输入的 URL 地址的请求是否已经被缓存过，如果请求被设置了强缓存则取浏览器本地缓存，如果强缓存失效、或没有强缓存时，去请求服务器获取内容，这时候走的是协商缓存。

## DNS 域名解析

在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器 IP 地址这项工作，是由 DNS 服务器来完成的。

- **目的**：将域名解析成对应的服务器 IP 地址
- **若果本地 DNS 服务器有缓存：**

```text
检查浏览器缓存 ---> 检查操作系统缓存 ---> 检查路由器缓存 ---> 检查 ISP DNS 缓存 ---> 检查本地域名服务器
```

- **若果本地 DNS 服务器没有缓存**：则不能直接将域名转换为 IP 地址，需要采用*递归查询*的方式依次检查**浏览器缓存**、**操作系统缓存**、**本地域名服务器**，若还未找到则**本地域名服务器**会采用*迭代查询*的方式依次向**根域名服务器**、**顶级域名服务器**、**权威域名服务器**发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。

1. 首先搜索 **浏览器的 DNS 缓存**，缓存中维护着一张域名与 IP 地址的对应表；
2. 若没有命中，则*递归查询*继续搜索 **操作系统的 DNS 缓存**；
3. 若仍然没有命中，则操作系统将域名发送至 **本地域名服务器**，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果
   - （注意：主机和本地域名服务器之间的查询方式是 _递归查询_）；
4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行 **迭代查询**：
   - （注意：本地域名服务器和其他域名服务器之间的查询方式是 _迭代查询_，防止根域名服务器压力过大）：
   - 首先本地域名服务器向 **根域名服务器** 发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回 **顶级域名服务器** 的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案；
   - 本地域名服务器拿到这个 **顶级域名服务器** 的地址后，就向其发起请求，获取 **权威域名服务器** 的地址；
   - 本地域名服务器根据 **权威域名服务器** 的地址向其发起请求，最终得到该域名对应的 IP 地址。
5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来；
6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；
7. 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来。

### DNS 负载均衡

DNS 还有负载均衡的作用，现在很多网站都有多个服务器，当一个网站访问量过大的时候，如果所有请求都请求在同一个服务器上，可能服务器就会崩掉，这时候就用到了 DNS 负载均衡技术。
当一个网站有多个服务器地址时，在应答 DNS 查询的时候，DNS 服务器会对每个查询返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。例如可以根据每台机器的负载量，或者该机器距离用户的地理位置距离等等条件。

### DNS 预解析

大型网站，有多个不同服务器资源的情况下，都可采取 DNS 预解析，提前解析，减少页面卡顿。

> `<link rel="dns-prefetch" href="//api.xxx.cn">`
> link 设置 `rel="dns-prefetch"` 预解析即将用到的请求，减少响应时间

## 建立 TCP 连接

[三次握手和四次挥手](../12-网络/05-TCP三次握手&四次握手.md)

**目的**：建立客户端跟服务器的信息传输通道

在上一步我们通过 DNS 解析拿到服务器 IP 地址后，浏览器再通过系统调用 Socket 接口与服务器 443 端口进行通信，首先就是浏览器要与服务器建立 TCP 连接（也就是**三次握手**）。

首先，判断是不是 HTTPS 的，如果是，则 HTTPS 其实是`HTTP + SSL / TLS`两部分组成，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。

1. `（第一次握手）`客户端给服务器发送 SYN、MSS 的分组及额外信息；
2. `（第二次握手）`服务器收到客户端的信息并发送带有 SYN+ACK 标志位的分组；
3. `（第三次握手）`客户端确认收到服务器的分组，发送带有 ACK 标志位的分组，从而建立 TCP 连接。

**注意：**
**如果客户端此前未与服务器建立会话，那么双方需要进行一次完整的 TLS 四次握手**

1. `（第一次握手）`客户端首先向服务器发送 Client Hello 报文，包含一个**随机数**、**TLS 协议版本**、**按优先级排列的加密套件列表**；
2. `（第二次握手）`服务器向客户端发送 Server Hello 报文，包含一个**新的随机数**、**TLS 协议版本**、**经过选择后的一个加密套件**；
   - 服务器向客户端发送 Certificate 报文，包含服务器 X.509 证书链，其中，第一个为主证书，中间证书按照顺序跟在主证书之后，而根 CA 证书通常内置在操作系统或浏览器中，无需服务器发送；
   - 如果密钥交换选择 DH 算法，服务器会向客户端发送 Server Key Exchange 报文，包含密钥交换所需的 DH 参数；
   - 如果密钥交换选择 RSA 算法，则跳过这一步。服务器向客户端发送 Server Hello Done 报文，表明已经发送完所有握手消息；
3. `（第三次握手）`客户端向服务器发送 Client Key Exchange 报文
   - 如果密钥交换选择 RSA 算法，由客户端生成预主密钥，使用服务器证书中的公钥对其加密，包含在报文中，服务器只需使用自己的私钥解密就可以取出预主密钥；
   - 如果密钥交换选择 DH 算法，客户端会在报文中包含自己的 DH 参数，之后双方都根据 DH 算法计算出相同的预主密钥。需要注意的是，密钥交换的只是预主密钥，这个值还需进一步加工，结合客户端和服务器两个随机数种子，双方使用 PRF（pseudorandom function，伪随机函数）生成相同的主密钥；
   - 客户端向服务器发送 Change Cipher Spec 报文，表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密；
   - 客户端向服务器发送 Finished 报文，这条消息是经过加密的，因此在 Wireshark 中显示的是 Encrypted Handshake Message。如果服务器能解密出报文内容，则说明双方生成的主密钥是一致的。
4. `（第四次握手）`服务器向客户端发送 New Session Ticket 报文，而这个 Session Ticket 只有服务器才能解密，客户端把它保存下来，在以后的 TLS 重新握手过程中带上它进行快速会话恢复，减少往返延迟；
   - 服务器向客户端发送 Change Cipher Spec 报文，同样表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密；
   - 服务器向客户端发送 Finished 报文，如果客户端能解密出报文内容，则说明双方生成的主密钥是一致的。
   - 至此，完成所有握手协商。

**备注：**

> **ACK**：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0。TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。
> **SYN**(SYNchronization)：在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。
> **FIN**(finis）即完，终结的意思，用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

## 发送 HTTP 请求

**目的：**
给服务器发送所要请求的数据的信息

建立起安全的加密信道后，浏览器开始发送 HTTP 请求，一个请求报文由`请求行`、`请求头`、`空行`、`实体`（Get 请求没有）组成。

请求头由`通用首部`、`请求首部`、`实体首部`、`扩展首部`组成。

- 通用首部：表示无论是请求报文还是响应报文都可以使用，比如 Date；
- 请求首部：表示只有在请求报文中才有意义，分为 `Accept 首部`、`条件请求首部`、`安全请求首部`和`代理请求首部`这四类；
- 实体首部：作用于实体内容，分为`内容首部`和`缓存首部`这两类；
- 扩展首部：表示用户自定义的首部，通过 X- 前缀来添加。
- 另外需要注意的是：**HTTP 请求头是不区分大小写的**，它基于 ASCII 进行编码，而实体可以基于其它编码方式，由 Content-Type 决定。

### 请求方法

- `GET`：获取资源
- `POST`：传输实体主体
- `HEAD`：获取报文首部
- `PUT`：传输文件
- `DELETE`：删除文件
- `OPTIONS`：询问支持的方法
- `TRACE`：追踪路径

### 请求报文

## 服务器处理请求

**目的：**
将请求的数据按照请求的条件准备好

服务器端收到请求后的由 web 服务器（准确说应该是 http 服务器）处理请求，诸如 Apache、Ngnix、IIS 等。web 服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过 web 服务器返回给浏览器客户端。

## 返回响应结果

**目的：**
将请求的数据返回给客户端

浏览器接收到来自服务器的响应资源后，会对资源进行分析。
首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。
如果响应资源进行了压缩（比如 gzip），还需要进行解压。
然后，对响应资源做缓存。
接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。
此外，浏览器和服务器必须保证 HTTP 的传输顺序，各自维护的队列中请求/响应顺序必须一一对应，否则会出现乱序而出错的情况。

### 维持连接

完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。在 HTTP/1.1 中，`Connection: keep-alive` 是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。
在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。
同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。
注意，HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们完全不相同，一个作用于应用层，一个作用于传输层。

### 状态码

[常见状态码](../12-网络/04-常见状态码.md)

- 1xx 接收的请求正在处理
- 2xx 请求正常处理完毕
- 3xx 需要进行附加操作以完成请求
- 4xx 服务器无法处理请求
- 5xx 服务器处理请求出错

### 响应报文

## 关闭 TCP 连接

**目的：**
当双方（客户端、服务器）超出设定时间没有请求或响应传递时，任意一方都可以发起关闭请求，以避免服务器与客户端双方的资源占用和损耗

1. （第一次挥手）客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。
2. （第二次挥手）服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
   - 此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。
3. （第三次挥手）如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。
4. （第四次挥手）客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 TIME_WAIT （时间等待）状态。

**注意**：这个时候由服务端到客户端的 TCP 连接并未释放掉，需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。

## 浏览器解析 HTML 并渲染

[浏览器渲染原理及流程](./02-浏览器渲染原理及流程.md)

准确地说，浏览器需要加载解析的不仅仅是 HTML，还包括 CSS、JS。以及还要加载图片、视频等其他媒体资源。

### 渲染基本流程

1. **构建 DOM 树**： 处理 HTML 标记并构建 DOM 树；
2. **构建 CSS Rule Tree 树**： 处理 CSS 标记并构建 CSS Rule Tree 树；
3. **合并为渲染树**： 将 DOM 与 CSS Rule Tree 合并成一个渲染树；
4. **布局**： 根据渲染树来布局，以计算每个节点的几何信息；
5. **绘制**： 将各个节点绘制到屏幕上。

### JavaScript 阻塞解析

当遇到`<script>`时，暂停 HTML 解析，加载解析执行 JS 代码。因为 JS 可能会改变 Html 的结构导致重新 reflow 和 repaint。[资源加载方式](./05-defer&async.md)

---

**这里简单说一种通过浏览器不同进程的角度来看这个问题的：**

- 浏览器进程：
  - 用户输入内容，进行 URL 解析（编码）
  - 如果是文本，则拼接成默认搜索引擎加关键字的 URL 进行搜索
  - 如果是 URL 就进行页面访问请求，并加上协议头（http、https 的区别）
- 网络进程：
  - 查询缓存（缓存相关知识）
  - 如果有浏览器本地缓存可用则使用本地缓存
  - DNS 解析（DNS 相关）
  - 通过 DNS 来查询 IP 地址
  - DNS 先查本地、后查运营商、逐级向上查。（域名解析是从后往前查的）
  - 拿到 IP 地址发起 HTTP 请求（这块可以问网络相关各种基础知识，TCP、IP、UDP、HTTPS、HTTP2）
  - 建立 TCP 三次握手连接
  - 如果是 HTTPS 建立 TLS 安全通道连接（HTTPS 加密方式）
  - 发送 HTTP 请求，这个请求可能回到代理服务器或者源服务器。（服务器代理）
  - 拿到 HTTP 响应（HTTP 响应码）
  - 根据 Content-Type 来判断响应文件类型（常用 HTTP 响应头的作用）
  - stream 类，浏览器启动下载界面下载文件。
  - text、图片类，浏览器直接展示在页面上
  - html 类型，浏览器会进行页面解析。
- 渲染进程：
  - 页面解析
  - 网络进程向渲染进程传输 HTML 数据
  - 对 HTML 进行词法分析，通过堆栈算法构建 DOM 树。（AST 语法树）
  - 如果遇到外部资源，浏览器会交给网络进程去下载。
  - 构建完 DOM 树的同时，将 CSS 代码转为浏览器可以理解的 StyleSheets
  - 标准化样式属性值（单位、大小）
  - 计算出 DOM 树每个节点的具体样式
  - 计算每个 DOM 节点的父节点们的样式（样式继承）
  - DOM 树构建完成后， 合并 StyleSheets 构建出 CSSOM 渲染树。
  - 排版：遍历渲染树，计算元素的坐标位置。
  - 分层：为节点生成图层
  - 绘制：用浏览器指令逐条绘制页面元素。（如何避免重绘重排）
  - 栅格化
  - 合成

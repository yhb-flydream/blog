# 继承

> **参考**
>
> [【JavaScript 深入之继承的多种方式和优缺点】(作者：冴羽)【来源：掘金】](https://juejin.cn/post/6844903477819211784)

[TOC]

## 原型链继承

```js
function Parent() {
  this.name = 'zs'
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child() {}

Child.prototype = new Parent()

var child = new Child()

console.log(child.name) // zs
```

## 借用构造函数(经典继承)

```js
function Parent() {
  this.names = ['zs', 'ls']
}

function Child() {
  Parent.call(this)
}

var child1 = new Child()

child1.names.push('ww')

console.log(child1.names) // ["zs", "ls", "ww"]

var child2 = new Child()

console.log(child2.names) // ["zs", "ls"]
```

## 组合继承

> 原型链继承和经典继承双剑合璧。

```js
function Parent(name) {
  this.name = name
  this.colors = ['red', 'yellow', 'green']
}
Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
Child.prototype = new Parent()

var child1 = new Child('zs', 18)
child1.colors.push('blue')

console.log(child1.name) // kevin
console.log(child1.age) // 18
console.log(child1.colors) // ["red", "blue", "green", "blue"]

var child2 = new Child('daisy', '20')

console.log(child2.name) // daisy
console.log(child2.age) // 20
console.log(child2.colors) // ["red", "blue", "green"]
```

## 原型式继承

```js
function createObj(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

就是 ES5 `Object.create` 的模拟实现，将传入的对象作为创建的对象的原型。

```js
var person = {
  name: 'kevin',
  friends: ['daisy', 'kelly'],
}

var person1 = createObj(person)
var person2 = createObj(person)

person1.name = 'person1'
console.log(person2.name) // kevin

person1.firends.push('taylor')
console.log(person2.friends) // ["daisy", "kelly", "taylor"]
```

## 寄生式继承

```js
function createObj(o) {
  var clone = object.create(o)
  clone.sayName = function () {
    console.log('hi')
  }
  return clone
}
```

## 寄生组合式继承

```js
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

// 关键的三步
Child.prototype = Object.create(Parent.prototype)

var child1 = new Child('kevin', '18')

console.log(child1)
```

```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function prototype(child, parent) {
  var prototype = object(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

// 当我们使用的时候：
prototype(Child, Parent)
```

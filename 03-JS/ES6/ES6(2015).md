# ES6（ES2015）

> 开发更简洁
> 新特性

[TOC]

## Babel 转码器

- 配置文件`.babelrc`

```json
{
  "presets": [],
  "plugins": []
}
```

- `presets`字段设定转码规则，官方提供以下的规则集，可以根据需要安装

```bash
# 最新转码规则
$ npm install --save-dev babel-preset-latest

# react 转码规则
$ npm install --save-dev babel-preset-react

# 不同阶段语法提案的转码规则（共有4个阶段），选装一个
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
```

- 然后，将这些规则加入`.babelrc`

```json
{
  "presets": [
  "latest",
  "react",
  "stage-2"
  ],
  "plugins": []
}
```

**以下所有 Babel工具和模块的使用，都必须先写好`.babelrc`**

### 命令行转码`babel-cli`

- Babel提供的`babel-cli`工具，用于命令行转码
- `npm install -g babel-cli` 全局安装

- **基本用法如下：（前提是有全局的Babel）**

```bash
# 转码结果输出到标准输出
$ babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ babel example.js --out-file compiled.js
# 或者
$ babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ babel src --out-dir lib
# 或者
$ babel src -d lib

# -s 参数生成source map文件
$ babel src -d lib -s
```

- 另外每一个项目中也应有`babel-cli`
- `npm install --save-dev babel-cli` 安装到项目中
- 然后改写`package.json` `scripts` 字段

```json
{
  // ...
  "devDependencies": {
    "babel-cli": "^6.0.0"
  },
  "scripts": {
    "build": "babel src -d lib"
  },
}
```

- 转码时只需执行`npm run build`

## 严格模式

- ES5中的模式
- 目的：
  - 消除JavaScript不规则格式

## `let和const`

### `let`（定义变量，可重新赋值）

- **无变量提升**，必须先定义否则报错
- **有块级作用域**，一定程度上替代了`立即执行函数(function() {}())`
- **不允许重复声明**
  - let不允许在相同作用域内`{}`，重复声明同一个变量
- **暂时性死区**

```js
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

> 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp
> 导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
> ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量
> 从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
> 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”

```js
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

> 上面代码中，**在let命令声明变量tmp之前**，都属于变量tmp的“死区”，temp的操作会出错
> “暂时性死区”也意味着typeof不再是一个百分之百安全的操作

```
typeof x; // ReferenceError
let x;
// 变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。
// 因此，typeof运行时就会抛出一个ReferenceError


typeof x; // "undefined"
// 如果一个变量根本没有被声明，使用typeof反而不会报错
```

##### do 表达式

- 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值

```
{
  let t = f();
  t = t * t + 1;
}
```

- 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量
- 现在有一个`提案（ES6没用到）`，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为`do表达式`

```
let x = do {
  let t = f();
  t * t + 1;
};
```

- 上面代码中，变量x会得到整个块级作用域的返回值

##### `const`（定义常量，不可重新赋值）

- `一旦赋值，不可改变`，并立即初始化数据
- `有块级作用域`
- `无变量提升`
- `暂时性死区`，只能在声明的位置后面使用
- `不可重复声明`

**const本质**

> const实际上保证的，并不是变量的值不得改动，而是变`量指向的那个内存地址不得改动`。
> 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
> 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。
> 因此，将一个对象声明为常量必须非常小心

```
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

> 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。
> 不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性

#### 字符串的扩展

- `string`扩展方法
  - `includes`
    - `str.includes()`
    - 是否包含字符串中的某个字符
    - 返回值 `true|false`
  - `startsWith`
    - `str.startsWith()`
    - 参数字符串是否在源字符串的头部
    - 返回值 `true|false`
  - `endsWith`
    - `str.endsWith()`
    - 参数字符串是否在源字符串的尾部
    - 返回值 `true|false`
  - `repeat`
    - `str.repeat()`
    - 返回一个新字符串，表示将原字符串重复n次
    - `var str = "x"; str.repeat(3) // "xxx"`
  - `padStart`
    - `str.padStart()`
    - 如果某个字符串不够指定长度，会在头部补全
    - `'x'.padStart(5, 'ab') // 'ababx'`
    - `'x'.padStart(4, 'ab') // 'abax'`
  - `padEnd`
    - `str.padEnd()`
    - 如果某个字符串不够指定长度，会在头部补全
    - `'x'.padEnd(5, 'ab') // 'xabab'`
    - `'x'.padEnd(4, 'ab') // 'xaba'`
      - `padStart` 和 `padEnd` 一共接受两个参数
      - 第一个参数用来指定字符串的最小长度
      - 第二个参数是用来补全的字符串
    - 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串
      - `'xxx'.padStart(2, 'ab') // 'xxx'`
      - `'xxx'.padEnd(2, 'ab') // 'xxx'`
    - 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串
      - `'abc'.padStart(10, '0123456789')    // '0123456abc'`
    - 如果省略第二个参数，默认使用空格补全长度
      - `'x'.padStart(4) // '   x'`
      - `'x'.padEnd(4) // 'x   '`
    - `padStart` 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串
      - `'1'.padStart(10, '0') // "0000000001"`
      - `'12'.padStart(10, '0') // "0000000012"`
      - `'123456'.padStart(10, '0') // "0000123456"`
    - 另一个用途是提示字符串格式
      - `'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"`
      - `'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"`

##### ES6 声明变量的六种方法

- `var`
- `function`
- `let`
- `const`
- `import`
- `class`

##### 取顶层对象

```
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

#### 变量的解构赋值

##### 数组的解构赋值

- 基本用法
- **ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构**
- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值

```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

- **如果解构不成功，变量的值就等于 `undefined`**

```
let [foo] = [];
let [bar, foo] = [1];
// foo = undefined
```

- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功

```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

- 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错

```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

##### 默认值

- 解构赋值允许指定默认值

```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

- ES6 内部使用严格相等运算符`（===）`，判断一个位置是否有值。所以，只有当一个数组成员`严格等于 undefined`，默认值才会生效

```
let [x = 1] = [undefined];  // 严格等于 undefined 不生效
x // 1

let [x = 1] = [null]; // 没有严格等于 undefined 生效
x // null
```

##### 对象的解构赋值

```
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

- **对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。**

```
let { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined
```

- 如果变量名与属性名不一致，必须写成下面这样

```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

- 对象的解构赋值是下面形式的简写

```
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

- 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。**真正被赋值的是后者，而不是前者。**

```
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined

// 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo
```

- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error

// 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题

// 正确的写法
let x;
({x} = {x: 1});
```

##### 字符串的解构

- 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个**类似数组的对象**

```
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

- 类似数组的对象都有一个 `length` 属性，因此还可以对这个属性解构赋值
- `let {length : len} = 'hello';    len // 5`

##### 数值和布尔值的解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象

```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
  - `let { prop: x } = undefined; // TypeError`
  - `let { prop: y } = null; // TypeError`

##### 函数参数的解构赋值

- 函数的参数也可以使用解构赋值

```
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```

##### 圆括号问题

- 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。
- 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
- 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号

##### 不能使用圆括号的情况

- 1、变量声明语句

```
// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };

// 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号
```

- 2、函数参数
- 函数参数也属于变量声明，因此不能带有圆括号

```
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

- 3、赋值语句的模式

```
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];

// 上面代码将整个模式放在圆括号之中，导致报错

// 报错
[({ p: a }), { x: c }] = [{}, {}];

// 上面代码将一部分模式放在圆括号之中，导致报错
```

##### 可以使用圆括号的情况

- 可以使用圆括号的情况只有一种：**`赋值语句的非模式部分，可以使用圆括号`**

```
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

- 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；
- 其次它们的圆括号都不属于模式的一部分。
- 第一行语句中，模式是取数组的第一个成员，跟圆括号无关；
- 第二行语句中，模式是p，而不是d；
- 第三行语句与第一行语句的性质一致

#### 用途

- 变量的解构赋值用途很多
- 1、交换变量的值

```
let x = 1;
let y = 2;

[x, y] = [y, x];
// 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰
```

- 2、从函数返回多个值
- 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便

```
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
```

- 3、函数参数的定义
- 解构赋值可以方便地将一组参数与变量名对应起来

```
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

- 4、提取 JSON 数据
- 解构赋值对提取 JSON 对象中的数据，尤其有用

```
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
// 上面代码可以快速提取 JSON 数据的值
```

- 5、函数参数的默认值

```
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
// 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句
```

- 6、遍历 Map 结构
- 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便

```
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world

// 如果只想获取键名，或者只想获取键值，可以写成下面这样

// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
```

- 7、输入模块的指定方法

- 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰

```
const { SourceMapConsumer, SourceNode } = require("source-map");
```

#### **字符串模板   \`\`**

```
let a = 'aaaaa'
console.log(`${a}`)  // aaaaa
```

- 所有模板字符串的空格和换行，都是被保留的，比如 `<ul>` 标签前面会有一个换行。如果你不想要这个换行，可以使用`trim `方法消除它

```
$('#list').html(`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`.trim());
```

- 模板字符串之中还能调用函数

```
function fn() {
  return "Hello World";
}

`foo ${fn()} bar`
// foo Hello World bar
```

- 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 `toString` 方法。
- **如果模板字符串中的变量没有声明，将报错**

```
// 变量place没有声明
let msg = `Hello, ${place}`;
// 报错
```

- **`模板字符串甚至还能嵌套`**

```
const tmpl = addrs => `
  <table>
  ${addrs.map(addr => `
    <tr><td>${addr.first}</td></tr>
    <tr><td>${addr.last}</td></tr>
  `).join('')}
  </table>
`;
```

- 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下
```
const data = [
    { first: '<Jane>', last: 'Bond' },
    { first: 'Lars', last: '<Croft>' },
];

console.log(tmpl(data));
// <table>
//
//   <tr><td><Jane></td></tr>
//   <tr><td>Bond</td></tr>
//
//   <tr><td>Lars</td></tr>
//   <tr><td><Croft></td></tr>
//
// </table>
```

- 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写

```
// 写法一
let str = 'return ' + '`Hello ${name}!`';
let func = new Function('name', str);
func('Jack') // "Hello Jack!"

// 写法二
let str = '(name) => `Hello ${name}!`';
let func = eval.call(null, str);
func('Jack') // "Hello Jack!"
```

#### 实例：模板编译

#### 标签模板`tag`@

```
var a = 5;
var b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
```

- 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值
- tag函数所有参数的实际值如下
  - 第一个参数：['Hello ', ' world ']
  - 第二个参数: 15
  - 第三个参数：50
- 也就是说，tag函数实际上以下面的形式调用
  - `tag(['Hello ', ' world '], 15, 50)`

#### `String.raw()`

- 使用`raw`可以不使字符串模板转译，以原始值输出

```
let raw = String.raw`Not a newline: \n`;
  document.write(raw === 'Not a newline: \\n'); // true
```

#### `Math`方法

- `Math.trunc()`去除一个数的小数部分，返回整数部分
  - `Math.trunc(4.1) // 4`
  - `Math.trunc(-4.1) // -4`
- `Math.sign()`判断一个数是整数、负数、零
  - 返回值：
    - 正数： +1 `Math.sign(-5) // -1`
    - 负数： -1 `Math.sign(5) // +1`
    - 0： 0 `Math.sign(0) // +0`
    - -0： -0 `Math.sign(-0) // -0`
    - 其他值： NaN `Math.sign('hubwiz'); // NaN`
- `Math.cbrt()`计算一个数的立方根
  - `Math.cbrt(-1); // -1`
  - `Math.cbrt(0); // 0`
  - `Math.cbrt(2); // 1.2599210498948732`
- `Math.frounf()`返回一个数的单精度浮点数形式
  - `Math.fround(0); // 0`
  - `Math.fround(1.337); // 1.3370000123977661`
  - `Math.fround(NaN); // NaN`
- `Math.hypot()`返回所有参数的平方和的平方根
  - `Math.hypot(3,4); // 5`
  - `Math.hypot(-3); // 3`
  - `Math.hypot(3, 4, '5'); // 7.0710678118654755`
  - `Math.hypot(3, 4, 5); // 7.0710678118654755`
  - `Math.hypot(NaN); // NaN`
  - `Math.hypot(3, 4, 'foo'); // NaN`

#### Array

##### `Array.from`

- 将两类对象转为真正的数组
  - 类似数组的对象
  - 可遍历（iterable）的对象

```
let list = document.querySelectorAll('ul.fancy li');

Array.from(list).forEach(function (li) {
  document.write(li);
});

// querySelectorAll方法返回的是一个类似数组的对象,只有将这个对象转为真正的数组，才能使用forEach方法

// 任何有length属性的对象，都可以通过Array.from方法转为数组
let array = Array.from({ 0: "a", 1: "b", 2: "c", length: 3 });
document.write(array);    // [ "a", "b" , "c" ]
```

- Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理

```
let array = [0,1,2,3,4];
let arrNew = Array.from(array, x => x * x);
console.log(arrNew);
// 等同于
let arrNew = Array.from(array).map(x => x * x);

Array.from([1, , 2, , 3], (n) => n || 0)
// [1, 0, 2, 0, 3]
```

- Array.from()的一个应用是，将字符串转为数组，然后返回字符串的长度

```
function countSymbols(string) {
  return Array.from(string).length;
}
```

##### `Array.of`

- 将一组值，转换为数组
- 为了弥补构造函数Array()的不足

```
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1

// 如果只用Array  来new函数，当只有一个参数时，只是设置了返回的数组的长度
Array() // []
Array(3) // [undefined, undefined, undefined]
Array(3,11,8) // [3, 11, 8]
```

##### 实例的`find`方法

- 找出第一个符合条件的数组成员和它的位置
  - 回调函数的参数：
    - 当前值
    - 值的索引
    - 原数组
  - 参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined

```
let array = [1, 4, -5, 10].find((n) => n < 0);
document.write("array:", array);
```

##### 实例的`findIndex`方法

- 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1

```
let index = [1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
})
document.write(index);  // 2

[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

- indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助[Object.is](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)法做到

##### 实例的`fill`填充数组

- 使用定值填充一个数组

```
let arr = ['a', 'b', 'c'].fill(7)
document.write(arr);  // [7, 7, 7]

let newArr = new Array(3).fill(7)
document.write(newArr);  // [7, 7, 7]
```

- fill()还可以接受第二个和第三个参数，
- 用于指定填充的**起始位置**和**结束位置**

```
let newArr = ['a', 'b', 'c'].fill(7, 1, 2)
document.write(newArr);   // ['a', 7, 'c']
```

##### 实例中的`entries()、keys()、values()`

- 用于遍历数组
- 都返回一个遍历器，可以用`for...of`进行遍历
- 唯一区别是`keys()`是对键名的遍历、`values()`是对键值的遍历、`entries()`是对键值对的遍历
```

for (let index of ['a', 'b'].keys()) {
  document.write(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  document.write(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  document.write(index, elem);
}
// 0 "a"
// 1 "b"
```

#### 对象

##### 属性简洁表达法

```
function f( x, y ) {
  return { x, y };
}
// 等同于
function f( x, y ) {
  return { x: x, y: y };
}

var Person = {
            name: '张三',
            birth:'1990-01-01',
            // 等同于hello: function ()...
            hello() { document.write('我的名字是', this.name); }
          };
Person.hello();

function getPoint() {
  var x = 1;
  var y = 10;
  return {x, y};
}
getPoint();   // {x:1, y:10}
```

##### 属性名表达式

```
// 原定义对象的属性
let obj = {};
obj.foo = true;
obj.["a" + "bc"] = 123;
// {foo: true, abc: 123}
let propKey = 'foo';

// es6中 可以将属性名放在方括号内
let obj = {
    [propKey]: true,
    ['a'+'bc']: 123,
    ["h" + "ello"]() {
    return 'hi'
  }
};
// {foo: true, abc: 123}
// obj.hello(); // hi
```

##### 比较两个值是否严格相等

- `Object.is()`与`===`行为基本一致，不同之处在于
  - `+0`不等于`-0`
  - `NaN`等于自身

```
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

##### 源对象的所有可枚举属性，复制到目标对象

- `Object.assign()`
  - 至少需要两个对象做参数，第一个是目标对象，后面的参数都是源对象
  - 只要有一个参数不是对象，就会抛出`TypeError`错误

```
var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性

var target = { a: 1, b: 1 };

var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

##### `proto`属性@

- 用来读取或设置当前对象的`prototype`对象。
- 该属性一度被正式写入ES6草案，后被移除，目前所有浏览器都部署了这个属性

```
// es6的写法
var obj = {
  __proto__: someOtherObj,
  method: function() { ... }
}

// es5的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... }
```

##### `Symbol`类型@

- 表示独一无二的ID
- 凡是属性属于`Symbol`类型，就独一无二，可以保证不会与其他属性名产生冲突

```
let s = Symbol();

typeof s; // "symbol"
```

- **Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象**
- Symbol类型的值可以转为字符串

```
var sym = Symbol('My symbol');

String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
```

##### 内置代理`Proxy`@

- 内置的一个代理工具，使用他可以在对象处理上加一层屏障
- S6原生提供Proxy构造函数，用来生成Proxy实例
- `var proxy = new Proxy(target, handler)`

#### 函数

##### 可以定义函数的默认参数

```
function fn(name) {
  var name = name || 'aaa';
  console.log(name);
}
fn(); // aaa
// 使用es6参数
function fn(name='zs') {
  console.log(name);
}
fn(); // zs
fn('ls'); // ls
```

##### rest参数@

- 形式为`...变量名`
- 可成为不定参数，用于获取函数的多与参数，这样就不需要`arguments`对象了
- rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中

```
function add(...values) {
   let sum = 0;

   for (var val of values) {
      sum += val;
   }

   return sum;
}

add(1, 2, 3) // 6
```

- **不定参数的格式是三个句点后跟代表所有不定参数的变量名。比如以上示例中，...values 代表了所有传入add函数的参数**

##### 扩展运算符@

- 扩展运算符（spread）是三个点（`...`）,好比rest参数的逆运算，讲一个数组转换为用逗号分割的参数序列
- 该运算符用于函数调用
- 它允许传递数组或者类数组直接做为函数的参数`而不用通过apply`

```
var people=['张三','李四','王五'];

//sayHello函数本来接收三个单独的参数people1，people2和people3
function sayHello(people1,people2,people3){
    document.write(`Hello ${people1},${people2},${people3}`);
}

//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数
sayHello(...people);   //输出：Hello 张三,李四,王五

//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法
sayHello.apply(null,people);   //输出：Hello 张三,李四,王五
```

##### 箭头函数

- `=>`
- 函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象
- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
- 不可使用`arguments`对象，该对象在函数体内不存在

```
var arr = [1,2,3];
arr.forEach(function(item, index, arr) {
  console.log(item);
});
arr.forEach((item, index, arr)=> console.log(item));
```

##### 函数绑定@@

- `obj::fn`
  - 左边是一个对象，右边是一个函数
  - 该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边函数上

```
let log = ::console.log;
// 等同于
var log = console.log.bind(console);

foo::bar;
// 等同于
bar.call(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
```

##### 尾调用优化

- 指某个函数的最后一步是调用另一个函数

```
function f() {
    let m = 1;
    let n = 2;
    let g = (m, n) => m+n;
    return g(m, n);
}
console.log(f());
```

#### Set

##### 基本用法

- 数据结构Set类似于数组，但成员都是唯一的，没有重复

```
var s = new Set();

[2,3,5,4,5,2,2].map(x => s.add(x))

for (i of s) {document.write(i)}
// 2 3 5 4
```

- Set函数可以接受一个数组作为参数，用来初始化

```
var items = new Set([1,2,3,4,5,5,5,5]);
document.write(items.size); // 5
```

- 向Set加入值的时候，不会发生类型转换，所以5和“5”是两个不同的值

```
let set = new Set();
set.add({})
set.size // 1
set.add({})
set.size // 2

上面代码表示，由于两个空对象不是精确相等，所以它们被视为两个值
```

##### Set实例的属性

- `Set.prototype.constructor`构造函数，默认是Set函数
- `Set.prototype.size`返回Set实例的成员总数

```
let s = new Set();
s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2
```

##### Set实例的方法

- `add(val)`添加某个值，返回Set结构本身
- `delete(val)`删除某个值，返回一个布尔值，表示是否删除成功
- `has(val)`返回一个布尔值，表示该值是否是Set成员
- `clear()`清理所有成员，没有返回值

```
let s = new Set();
s.add(1).add(2).add(2);

s.has(1) // true
s.has(2) // true
s.has(3) // false
s.delete(2);
s.has(2) // false
```

- `Array.from`方法可以将Set结构转为数组：

```
var items = new Set([1, 2, 3, 4, 5]);
var array = Array.from(items);
```

##### 遍历操作

- `keys()`返回一个键名的遍历器
- `values()`返回一个键值的遍历器
- `entries()`返回一个键值对的遍历器
- `forEach()`使用回调函数遍历每个成员

```
let set = new Set(['red', 'green', 'blue']);

for ( let item of set.keys() ){
  document.write(item);
}
// red
// green
// blue

for ( let item of set.values() ){
  document.write(item);
}
// red
// green
// blue

for ( let item of set.entries() ){
  document.write(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]

set.forEach(function(item){
    document.write(item);
})
```

##### WeakSet

- WeakSet和Set一样都不存储重复的元素，但有一些不同点
- **WeakSet的成员只能是`对象`，而不能是其他类型的值**

```
var ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
```

- WeakSet结构有以下三个方法
  - `WeakSet.prototype.add(value)`向WeakSet实例添加新成员，无返回值
  - `WeakSet.prototype.delete(value)`清除实例指定成员，无返回值
  - `WeakSet.prototype.has(value)`实例是否存在某个值，返回布尔值

```
var ws = new WeakSet()
var obj = {};
var foo = {};

ws.add(obj);
ws.add(window);

ws.has(obj); // true
ws.has(foo); // flase

ws.delete(window);
ws.has(window); // false
```

- WeakSet没有size属性，没办法遍历它的成员
  - `ws.size // undefined`
  - `ws.forEach // undefined`

#### Map

- Map 是一个超对象，其key除了可以使String类型之外，还可以是其他类型（如：对象）

```
var m = new Map();
var o = {p: 'hello world'};
m.set(o, 'content');

console.log(m.get(o)); // content
```

##### Map的方法

- `size`返回成员总数
- `set(key, value)`设置一个键值对，可以链式操作
- `get(key)`读取一个键，得到对应值
- `has(key)`返回一个布尔值，表示某个键是否在Map数据结构中
- `delete(key)`删除某个键
- `clear()`清除所有成员
- `keys()`返回键值名的遍历器
- `values()`返回键值的遍历器
- `entries()`返回所有成员的遍历器

##### WeakMap@

- 与Map结构基本类似，唯一区别时他只接受对象作为键名（`null除外`），不接受原始类型的值作为键名，而且键名说着的对象，不计入垃圾回收机制
- `set()和get()`分别用来添加和获取数据

```
var map = new WeakMap(),
element = document.querySelector('.element');

map.set(element, 'Original');
var value = map.get(element);
document.write(value); // Original
```

- WeakMap与Map在API上的区别主要是两个
  - 一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；
  - 二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关
  - 因此，WeakMap只有四个方法可用：`get()、set()、has()、delete()`。

#### Iterator（遍历器）和`for...of`遍历@

##### `Iterator（遍历器）`

- 统一的接口机制，来处理所有不同的数据结构
- 三个作用
  - 为各种数据结构，提供一个统一的，渐变的访问接口
  - 使数据结构的成员能够按照某种次序排列
  - 提供`for  of`使用
- **遍历过程：**
  - 创建一个指针，指向当前数据结构的起始位置，也就是说遍历器返回值是一个只针对象
  - 第一次调用只针对象的next方法，可以将指针指向数据结构的第一个成员
  - 第二次调用指针对象的next方法，指针就指向数据结构的第二个成成员
  - 调用指针对象的next方法，直到指向数据结构的结束的位置
- 每一次调用next方法，都会返回当前成员的信息，具体来说，就是返回一个包含value和done两个属性的对象。
  - value属性是当前成员的值，
  - done属性是一个布尔值，表示遍历是否结束

##### 数据结构的默认Iterator接口@

- 在ES6中，可迭代数据结构(比如数组)都必须实现一个名为Symbol.iterator的方法，该方法返回一个该结构元素的迭代器。
- 注意，Symbol.iterator是一个Symbol，Symbol是ES6新加入的原始值类型

```
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
```

- 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器。

##### 调用默认Iterator接口的场合

- 有一些场合会默认调用iterator接口（`即Symbol.iterator方法`），除了下文会介绍的for...of循环，还有几个别的场合
- **解构赋值**
  - 对数组和Set结构进行解构赋值时，会默认调用iterator接口

```
let set = new Set().add('a').add('b').add('c');

let [x,y] = set;
// x='a'; y='b'

let [first, ...rest] = set;
// first='a'; rest=['b','c'];
```

- **扩展运算符**
  - 扩展运算符（`...`）也会调用默认的iterator接口

```
// 例一
var str = 'hello';
[...str] //  ['h','e','l','l','o']

// 例二
let arr = ['b', 'c'];
['a', ...arr, 'd']
// ['a', 'b', 'c', 'd']
```

- **其他场合**
  - 以下场合也会用到默认的iterator接口，可以查阅相关章节
  - `yieid*`
  - `Array.form()`
  - `Map(),Set(),WeakMap(),WeakSet()`
  - `Promise.all(),Promisr.race()`

##### 原生具备Iterator接口的数据结构@

- 字符串是一个类似数组的对象，也原生具有Iterator接口

```
var someString = "hi";
typeof someString[Symbol.iterator]
// "function"

var iterator = someString[Symbol.iterator]();

iterator.next()  // { value: "h", done: false }
iterator.next()  // { value: "i", done: false }
iterator.next()  // { value: undefined, done: true }
```

- 上面代码中，调用Symbol.iterator方法返回一个遍历器，在这个遍历器上可以调用next方法，实现对于字符串的遍历。
- 可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的

```
var str = new String("hi");

[...str] // ["h", "i"]

str[Symbol.iterator] = function() {
  return {
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: "bye", done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};

[...str] // ["bye"]
str // "hi"
```

- 上面代码中，字符串str的Symbol.iterator方法被修改了，所以扩展运算符（...）返回的值变成了bye，而字符串本身还是hi

##### Iterator接口与Generator函数

- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数

```
var myIterable = {};

myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]

// 或者采用下面的简洁写法

let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

for (let x of obj) {
  document.write(x);
}
// hello
// world
```

- 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可

##### 遍历器的`return()，throw()`

- 遍历器返回的指针对象除了具有next方法，还可以具有return方法和throw方法。
  - next方法是必须部署的
  - return方法和throw方法是否部署是可选的
- return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法
- throw方法主要是配合Generator函数使用，一般的遍历器用不到这个方法

##### `for of`循环

#### `Generator`

> 是一个函数的内部状态的遍历器（也就是说，Generator函数是一个状态机）

- 形式上，Generator函数是一个普通函数，但是有两个特征
  - 一是，function命令与函数名之间有一个星号`*`
  - 二是，函数体内部使用`yield`语句，定义遍历器的每一个成员，即不同的内部状态

```
function* generator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var gen = generator();
gen.next(); // {value: 'hello', done: false}

gen.next(); // {value: 'world', done: false}

gen.next(); // {value: 'ending', done: true}

gen.next(); // {value: undefined, done: true}
```

- 调用Generator函数，返回一个部署了Iterator接口的遍历器对象，用来操作内部指针。
- 以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。
  - value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；
  - done属性是一个布尔值，表示是否遍历结束

##### next 方法 的参数

> yield语句本身没有返回值，或者说总是返回undefined。
> next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值

```
function* f() {
  for(var i=0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }
```

- 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增

##### `for of`循环

> for...of循环可以自动遍历Generator函数，且此时不再需要调用next方法

```
function *foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  document.write(v);
}
// 1 2 3 4 5
```

- 上面代码使用for...of循环，依次显示5个yield语句的值。
- 这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中

##### throw方法

- Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误

```
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){
    document.write(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（'出错了'）;
// 出错了
```

- 上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try ... catch 代码块捕获。
- 这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的

##### yield*语句

- 如果yield命令后面跟的是一个遍历器，需要在yield命令后面加上星号`*`，表明它返回的是一个遍历器。这被称为`yield*`语句
- 其实yield关键字就是以一种更直观、便捷的方式让我们创建用于遍历有限序列集合的迭代器，而yield则用于将生成器函数的代码切片作为有限序列集合的元素（元素的类型为指令+数据，而不仅仅是数据而已）

```
// 定义生成器函数
function *enumerable(msg){
  document.write(msg)
  var msg1 = yield msg + '  after '
  document.write(msg1)
  var msg2 = yield msg1 + ' after'
  document.write(msg2 + ' over')
}


// 上述代码会被解析成
var enumerable = function(msg){
  var state = -1

  return {
    next: function(val){
      switch(++state){
         case 0:
                  document.write(msg + ' after')
                  break
         case 1:
                  var msg1 = val
                  document.write(msg1 + ' after')
                  break
         case 2:
                  var msg2 = val
                  document.write(msg2 + ' over')
                  break
      }
    }
  }
}
```

##### 作为对象属性的Generator函数

- 如果一个对象的属性是Generator函数，可以简写成下面的形式

```
let obj = {
  * myGeneratorMethod() {

  }
}

// 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。
// 它完整的形式如下，与上面的写法等价
let obj = {
  myGeneratorMethod: function * () {

  }
}
```

#### Promise

> promise 是一个对象用来传递异步操作消息
- 特点：
  - 对象状态不受外界影响。promise对象代表一个异步操作，有三种状态：`Pending（进行中）`、`Resolved(已完成又称Fulfilled)(已失败又称Rejected)`。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
  - 一旦状态改变，就不会在改变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的
- 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易
- 缺点：
  - 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消
  - 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
  - 第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

##### 基本使用

- Promise对象是一个构造函数，用来生成Promise实例

```
//创建promise
var promise = new Promise(function(resolve, reject) {
    // 进行一些异步或耗时操作
    if ( /*如果成功 */ ) {
        resolve("Stuff worked!");
    } else {
        reject(Error("It broke"));
    }
});
//绑定处理程序
promise.then(function(result) {
    //promise成功的话会执行这里
    document.write(result); // "Stuff worked!"
}, function(err) {
    //promise失败会执行这里
    document.write(err); // Error: "It broke"
});
```

- `resolve`函数的作用是，将Promise对象的状态从`“未完成”变为“成功”（即从Pending变为Resolved）`，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- `reject`函数的作用是，将Promise对象的状态从`“未完成”变为“失败”（即从Pending变为Rejected）`，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

##### Promise 实例添加状态改变时的回调函数

- Promise实例具有then方法，也就是说，`then方法是定义在原型对象`,作用是为Promise实例添加状态改变时的回调函数
- then方法两个参数：
  - Resolved状态的回调函数
  - Rejected状态的回调函数
- then方法返回的是一个新的Promise实例**（注意不是原来的Promise实例）**。因此可以采用链式写法，即then方法后面在调用另一个then方法

```
getJSON('/post.json').then(function (json) {
  return json.post;
}).then(function (post) {

})
```

- 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数

##### 指定发生错误时的回调函数

- Promise.prototype.catch方法是then(null, rejection)的别名，用于指定发生错误时的回调函数

```
getJSON('/post.json').then(function (posts) {
  // ...
}).cacth(function (error) {
  // 处理前一个回调函数运行时发生的错误
  console.log('错误', error);
})
```

- getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误

```
var promise = new Promise(function(resolve, reject) {
  throw new Error('test')
});
promise.catch(function(error) { document.write(error) });
// Error: test

// Promise抛出一个错误，就被catch方法指定的回调函数捕获
```

- Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获

```
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});

// 代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获
```

##### `Promise.all()`方法

- Promise.all()方法用于将多个Promise实例，包装成一个新的Promise实例
- `var p = Promise.all([p1,p2,p3]);` 代码中Promise.all方法接受一个数组参数,p1,p2,p3都是Promise实例对象（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例）
- p的状态由p1、p2、p3决定，分成两种情况
  - 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数
  - 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数

```
// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function(id){
  return getJSON("/post/" + id + ".json");
});

Promise.all(promises).then(function(posts) {
  // ...
}).catch(function(reason){
  // ...
});
```

##### `Promise.race()`方法

- 同样是将多个Promise实例，包装成一个新的Promise实例
- `var p = Promise.race([p1,p2,p3]);`
- 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数
- 如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理

##### `Promise.resolve()`方法

- 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用
- 如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved

```
var p = Promsie.resolve('hello');

p.then(function (s) {
  console.log(s); // hello
})
```

- 由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行

##### `Promise.reject()`方法

- Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数

```
var p = Promise.reject('出错了');

p.then(null, function (s){
  console.log(s); // 出错了
});
// 成一个Promise对象的实例p，状态为rejected，回调函数会立即执行
```

##### Generator函数与Promise的结合

- 使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象

```

function getFoo () {
  return new Promise(function (resolve, reject){
    resolve('foo');
  });
}

var g = function* () {
  try {
    var foo = yield getFoo();
    document.write(foo);
  } catch (e) {
    document.write(e);
  }
};

function run (generator) {
  var it = generator();

  function go(result) {
    if (result.done) return result.value;

    return result.value.then(function (value) {
      return go(it.next(value));
    }, function (error) {
      return go(it.throw(value));
    });
  }

  go(it.next());
}

run(g);

// Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法
```

##### async 函数

- 与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法

```
var asyncFn = async function () {
  var f1 = await readFile('/etc/fstab');
  var f2 = await readFile('/etc/shells');
  document.write(f1.toString());
  document.write(f2.toString());
}
```

- async函数对Generator函数的改进，体现在以下三点
  - 内置执行器。Generator函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行
    - `var result = asuyc = asyncReadFile()`    - 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
- 更广的适用性。co函数库约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）

#### Class

##### 基本语法

```
//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return '('+this.x+', '+this.y+')';
  }
}
// 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。
```

- `constructor`方法
  - 类的默认方法，通过new命令生成对象实例时，自动调用该方法
- 实例对象
  - `var point = new Point(2,3);`
- name属性
- `class Point {}  console.log(Point.name); // Point`
- class表达式

```
const MyClass = class fo {
  getClassName() {
    return fo.name;
  }
}
```

##### Class的继承

- Class之间可以通过extends关键字，实现继承
- 子类会继承父类的属性和方法

```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class CollorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  }
}
```

- 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。
- 注意：ColorPoint继承了父类Point，但是它的构造函数必须调用super方法。
- 下面是生成子类实例的代码

```
let cp = new ColorPoint(25, 8, 'green');

cp instanceof ColorPoint // true
cp instanceof Point // true
```

##### class的取值函数（getter）和存值函数（setter）

- 在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数

```
class MyClass {
  get prop() {
    return 'getter';
  }
  set prop(value) {
    document.write('setter: '+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// 'getter'
```

- 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了

##### Class的Generator的方法

- 如果某个方法之前加上星号（*），就表示该方法是一个Generator函数

```
class Foo {
  constructor(...args) {
    this.args = args;
  }
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}

for (let x of new Foo('hello', 'world')) {
  document.write(x);
}
// hello
// world
```

- 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器

##### class的静态方法

- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”

```
class Foo {
  static classMethod() {
    return 'hello';
  }
}
Foo.classMethod() // 'hello'
var foo = new Foo();
foo.classMethod()
// TypeError: undefined is not a function
```

- 父类的静态方法，可以被子类继承

```
class Foo {
  static classMethod() {
    return 'hello';
  }
}
class Bar extends Foo {
}
Bar.classMethod(); // 'hello'
```

- 静态方法也是可以从super对象上调用的

```
class Foo {
  static classMethod() {
    return 'hello';
  }
}
class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + ', too';
  }
}
Bar.classMethod();
```

##### `new.target`属性

- new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的

```
function Person(name) {
  if (new.target !== undefined) {
    this.name = name;
  } else {
    throw new Error('必须使用new生成实例');
  }
}

// 另一种写法
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用new生成实例');
  }
}

var person = new Person('张三'); // 正确
var notAPerson = Person.call(person, '张三');  // 报错
```

- Class内部调用new.target，返回当前Class
- 子类继承父类时，new.target会返回子类

##### 修饰器-类的修饰

- 修饰器（Decorator）是一个表达式，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持
- 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码

```
function testable(target) {
  target.isTestable = true;
}
 @testable
class MyTestableClass {}
console.log(MyTestableClass.isTestable) // true
```

- 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。
- 基本上，修饰器的行为就是下面这样
- 修饰器本质上就是能在编译时执行的函数

```
 @decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;
```

- 修饰器函数可以接受三个参数，依次是目标函数、属性名和该属性的描述对象。后两个参数可省略。上节修饰器-类的修饰1代码中，testable函数的参数target，就是所要修饰的对象。如果希望修饰器的行为，能够根据目标对象的不同而不同，就要在外面再封装一层函数

```
 function testable(isTestable) {
   return function(target) {
     target.isTestable = isTestable;
   }
 }

 @testable(true) class MyTestableClass () {}
 document.write(MyTestableClass.isTestable) // true

 @testable(false) class MyClass () {}
 document.write(MyClass.isTestable) // false
```

- 如果想要为类的实例添加方法，可以在修饰器函数中，为目标类的prototype属性添加方法

```
function testable(target) {
  target.prototype.isTestable = true;
}

 @testable
class MyTestableClass () {}

let obj = new MyClass();

document.write(obj.isTestable) // true
```

- 修饰器函数可以接受三个参数，后两个参数可省略。
  - 目标函数
  - 属性名
  - 该属性的描述对象。
- 上节修饰器-类的修饰1代码中，testable函数的参数target，就是所要修饰的对象。如果希望修饰器的行为，能够根据目标对象的不同而不同，就要在外面再封装一层函数

```
 function testable(isTestable) {
   return function(target) {
     target.isTestable = isTestable;
   }
 }

 @testable(true) class MyTestableClass () {}
 document.write(MyTestableClass.isTestable) // true

 @testable(false) class MyClass () {}
 document.write(MyClass.isTestable) // false
```

- 如果想要为类的实例添加方法，可以在修饰器函数中，为目标类的prototype属性添加方法

```
function testable(target) {
  target.prototype.isTestable = true;
}

 @testable
class MyTestableClass () {}

let obj = new MyClass();

document.write(obj.isTestable) // true
```

#### Module

##### export

- 模块功能主要由两个命令构成：`export和inport`
  - `export`用于自定义模块，规定对外接口
  - `inport`用于输入其他模块提供的功能，同时创造命名空间，防止函数命名冲突
- ES6允许福利的js文件作为模块使用，允许一个JS脚本文件里调用另一个脚本文件
- 现有profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量

```
// profile.js
let firstName = 'zs';
let lastName = 'ls';
let year = 2000;

export {firstName, lastName, year};
```

##### import

- 使用export命令定义了模块对外接口之后，其他JS文件就可以通过`import`命令加载这个模块（文件）

```
// main.js
import {firstName, lastName, year} form './profile';

function getNameAndYear(ele) {
  ele.textContent = firstName + '' + lastName;
}
```

- 上面代码属于另一个文件main.js，import命令就用于加载profile.js文件，并从中输入变量
- import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名
- 大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同
- 如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名
  - `import {lastName as newName} from './profile';`

##### 模块整体输入

- export命令除了输出变量，还可以输出方法或类（class）
- 下面一个circle.js文件，输出了两个方法a和b

```
// circle.js
export function a(x) {
  return x + x;
}

export function b(x) {
  return x * x;
}
```

- 然后，main.js就可以引入circle.js模块

```
// main.js
import {a, b} from 'circle';
console.log(a(3)); //
console.log(b(3)); //
```

- 上面写法是逐个指定要引入的方法，另一种写法是整体引入

```
import * as circle from 'circle';
console.log(circle.a(3)); //
console.log(circle.b(3)); //
```

##### module

- module命令合一取代import，达到整体引入模块

```
// main.js
module circle from 'circle';
console.log(circle.a(3)); //
console.log(circle.b(3)); //
```

##### export default

- 为模块指定输出，使用`export default`

```
// demo.js
export default fucntion () {
  console.log(000);
}
```

- 上面代码是一个模块文件，它默认输出一个函数
- 其他模块加载该模块时，import命令可以为该匿名函数指定任一名字

```
// main.js
import newDemo from 'demo';
newDemo();
```

- 上面代码的import命令，可以用任意名称指向demo.js输出的方法。需要注意的是，这时import命令后面，不使用大括号

##### 模块继承

- 模块之间也可以继承

#### 编程风格

##### 块级作用域

- 使用`let`
  - 有块级作用域
  - 无变量提升

```
'use strict';

if (true) {
  let x = 'hello';
}

for(let i = 0; i < 10; i++) {
  console.log(i);
}

// 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。
// 变量应该只在其声明的代码块内有效，var命令做不到这一点
```

- 全局常量和线程安全
  - 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量
  - const优于let有几个原因。
    - 一个是const可以提醒阅读程序的人，这个变量不应该改变；
    - 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；
    - 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同
  - const声明常量还有两个好处，
    - 一是阅读代码的人立刻会意识到不应该修改这个值，
    - 二是防止了无意间修改变量值所导致的错误
  - 所有的函数都应该设置为常量
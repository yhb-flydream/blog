<!--
 * @Author: yaohebin
 * @Date: 2022-06-15 08:54:26
 * @LastEditTime: 2022-07-09 18:19:40
 * @LastEditors: yaohebin
 * @Description: 0.1+0.2!=0.3
-->

# 0.1+0.2!=0.3

> **参考**
>
> [《JavaScript 浮点数之迷：0.1 + 0.2 为什么不等于 0.3？》(作者：qufei1993)【来源：github】](https://github.com/qufei1993/Nodejs-Roadmap/blob/master/docs/javascript/floating-point-number-0.1-0.2.md)
>
> [《硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准》(作者：FESKY)【来源：掘金】](https://juejin.cn/post/6940405970954616839)
>
> [《0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？》(作者：Gladyu)【来源：掘金】](https://juejin.cn/post/6844903680362151950)

[TOC]

## 先修知识

1. 计算机内部都是采用二进制进行存储数据，即 `0 1` 编码。
2. N 个 bit 可以存储的整数是 2 的 N 次方个（8bit 为 2 的 8 次方 $2^{8}=256$）。
3. 计算机存储数据的标准是 IEEE 754，是以二进制数来表示数据。
4. 十进制小数转换为二进制，小数部分，需乘以 2 取整，若乘以后的小数部分不为 0，则继续乘以 2 知道小数部分为 0，将取出的整数正想排序。

**以下为 10 进制科学计数法表达式，底数为 10 ，其中 1≤|a|<10，n 为整数。**

$$
a*10^n
$$

例如，0.1 的科学计数法表示为 $0.1 = 1 * 10^{-1}$。（一个数的 -1 次方等于该数的倒数，例如 $10^{-1}$ = $\frac{10}{1}$）

**在 IEEE 754 标准中也类似，只不过它是以一个二进制数来表示，底数为 2**，以下为 0.1 的二进制表达式：

$$
1.10011001100110011(0011 无限循环) *  2^{-4}
$$

例如：0.1 转二进制

```text
0.1 * 2 = 0.2 --------------- 取整数 0，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
...
```

最终 0.1 的二进制表示为 0.00110011... 后面的 0011 将会无限循环，因此，**二进制无法精确的保存类似 0.1 这样的小数**。

但也不会无限循环，需要保存的位数在 IEEE 754 标准中也给出了限制。

## IEEE 754 标准

IEEE 754 常用的两种浮点数值的表示方式为：单精确度（32 位）、双精确度（64 位）。

### 双精度（64 位）

在 JavaScript 中不论小数还是整数只有一种数据类型表示，这就是 Number 类型，其遵循 IEEE 754 标准，使用双精度浮点数（double）64 位（8 字节）来存储一个浮点数（所以在 JS 中 1 === 1.0）。

**其中能够真正决定数字精度的是尾部，即（$2^{53-1}$）**

**64 Bits 分为以下 3 个部分：**

1. sign bit （S 符号）：用来标识正负号（1 bit）。【**0 为 正 1 为 负**】
2. exponent（E，指数）：用来表示次方数（11 bits）
3. mantissa（M，尾数）：用来表示精确度 1 <= M < 2（53 bits）

![64 Bits 分为 3 个部分（来自：https://mp.weixin.qq.com/s/EnXEdK8F8GWpKbeGOUGqqQ）](https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatKzibGm562iaiaC4Kibtnb3OmHe5BgLBmzL0gL5JDTiabh81FiaIAZQG4gNepNTTPA9ROfXWaHpc9FyqRyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![64 Bits 分为 3 个部分（来自：https://juejin.cn/post/6844903680362151950）](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/16/165e0eb7f4d6c50f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 0.1 在 IEEE 754 标准中是如何存储的？

### **1. “0.1” 转为二进制**

```text
0.000110011001100110011(0011) // 0011 将会无限循环
```

### **2. 二进制浮点数的科学计数法表示**

任何一个数都可以用科学计数法表示，0.1 的二进制科学计数法表示如下所示：

$$
1.10011001100110011(0011 无限循环) *  2^{-4}
$$

以上结果类似于十进制科学计数法表示：

$$
0.0001234567 = 1.234567 * 10^{-4}
$$

### **3. IEEE 754 存储**

0.1 的二进制表示如下所示：

$$
1.1001100110011001100110011001100110011001100110011001*2^{-4}
$$

- **符号位：**

由于 0.1 为正数，所以符号位 S = 0

- **指数位：**

E = -4，实际存储为 -4 + 1023 = 1019，二进制为 1111111011，E 为 11 位，最终为 01111111011

- **尾数位：**

在 IEEE 754 中，循环位就不能在无限循环下去了，在双精确度 64 位下最多存储的有效整数位数为 52 位，会采用 **就近舍入（round to nearest）模式（进一舍零）** 进行存储

```text
11001100110011001100110011001100110011001100110011001 // M 舍去首位的 1，得到如下
1001100110011001100110011001100110011001100110011001 // 0 舍 1 入，得到如下
1001100110011001100110011001100110011001100110011010 // 最终存储
```

- **最终存储结果：**

```text
0	01111111011	1001100110011001100110011001100110011001100110011010
```

![0.1  的 IEEE 754 存储结果（来自：https://www.javascriptc.com/books/nodejs-roadmap/javascript/floating-point-number-0.1-0.2.html）](https://www.javascriptc.com/books/nodejs-roadmap/javascript/img/ieee754_double_64_bit_0.1_binary.png)

## 0.1 + 0.2 等于多少？

0.1、0.2 对应的二进制分别如下所示：

```text
S  E            M
0  01111111011  1001100110011001100110011001100110011001100110011010 // 0.1
0  01111111100  1001100110011001100110011001100110011001100110011010 // 0.2
```

### 浮点数运算三步骤

1. 对阶
2. 求和
3. 规格化

### 对阶

浮点数加减首先要判断两数的**指数位**是否相同（小数点位置是否对齐），若两数指数位不同，需要对阶保证指数位相同。

对阶时遵守**小阶向大阶看齐原则**，尾数向右移位，每移动一位，指数位加 1 直到指数位相同，即完成对阶。

本示例，0.1 的阶码为 -4 小于 0.2 的阶码 -3，故对 0.1 做移码操作

```text
// 0.1 移动之前
0  01111111011  1001100110011001100110011001100110011001100110011010

// 0.1 右移 1 位之后尾数最高位空出一位，（0 舍 1 入，此处舍去末尾 0）
0  01111111100   100110011001100110011001100110011001100110011001101(0)

// 0.1 右移 1 位完成
0  01111111100  1100110011001100110011001100110011001100110011001101
```

尾数右移 1 位之后最高位空出来了，如何填补呢？涉及两个概念：

- 逻辑右移：最高位永远补 0
- 算术右移：不改变最高位值，是 1 补 1，是 0 补 0，尾数部分我们是有隐藏掉最高位是 1 的，不明白的再看看上面 **3.3 尾数位** 有讲解舍去 M 位 1。

### 尾数求和

两个尾数直接求和

```text
  0  01111111100   1100110011001100110011001100110011001100110011001101 // 0.1
+ 0  01111111100   1001100110011001100110011001100110011001100110011010 // 0.2
= 0  01111111100 100110011001100110011001100110011001100110011001100111 // 产生进位，待处理
```

或者以下方式：

```text
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
 10.0110011001100110011001100110011001100110011001100111
```

### 规格化和舍入

由于产生进位，阶码需要 + 1，对应的十进制为 1021，此时阶码为 1021 - 1023（64 位中间值）= -2，此时符号位、指数位如下所示：

```text
  S  E
= 0  01111111101
```

尾部进位 2 位，去除最高位默认的 1，因最低位为 1 需进行舍入操作（在二进制中是以 0 结尾的），舍入的方法就是在最低有效位上加 1，若为 0 则直接舍去，若为 1 继续加 1

```text
  100110011001100110011001100110011001100110011001100111 // + 1
=  00110011001100110011001100110011001100110011001101000 // 去除最高位默认的 1
=  00110011001100110011001100110011001100110011001101000 // 最后一位 0 舍去
=  0011001100110011001100110011001100110011001100110100  // 尾数最后结果
```

IEEE 754 中最终存储如下：

```text
0  01111111101 0011001100110011001100110011001100110011001100110100
```

最高位为 1，得到的二进制数如下所示：

```text
2^-2 * 1.0011001100110011001100110011001100110011001100110100
```

转换为十进制如下所示：

```text
0.30000000000000004
```

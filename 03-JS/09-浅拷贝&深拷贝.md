# 浅拷贝&深拷贝

> **参考**
>
> [《JavaScript 专题之深浅拷贝》(作者：冴羽)【来源：掘金】](https://juejin.cn/post/6844903487101222920)
>
> [《深入剖析 JavaScript 的深复制》(作者：邹润阳)【来源：咀嚼之味】](https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/)
>
> [《JavaScript 专题之从零实现 jQuery 的 extend》(作者：冴羽)【来源：掘金】](https://juejin.cn/post/6844903487386435592)
>
> [《js 浅拷贝、深拷贝（包括循环引用情况）》(作者：Tautus)【来源：CSDN】](https://blog.csdn.net/Snoopyqiuer/article/details/101106303)
>
> [《如何写出一个惊艳面试官的深拷贝?》(作者：抖音前端安全)【来源：掘金】](https://juejin.cn/post/6844903929705136141)

## 浅拷贝

> 对数据的单层级的复制
> 如果数据是引用数据类型的浅拷贝的话：
>
> - 它所包含的简单数据类型的值被复制，且拷贝前后的对象的值互不影响
> - 它所包含的引用数据类型的值被复制，只是复制了一份引用数据的指针地址，拷贝前后的引用数据值还会相互影响

### 浅拷贝的方法

- `Array.slice()`
- `Array.concat()`
- `Array.from()`
- `[...arr]`
- `Object.assign()`

## 深拷贝

> 对数据的完全的复制，逐层对数据进行复制
> 如果数据是引用数据类型的话：
>
> - 即使它所包含的有引用数据类型的值，也会继续对该值进行深层次的递归，完全的进行复制，完全指向了不同的内存地址

**针对循环引用：**

可以将这些循环引用使用 Map 或者 WeakMap 存储起来，并在发现引用时返回被引用过的对象，从而结束递归的调用（直接返回被引用过的对象可以防止再对引用对象进行深层次的循环，也就防止了循环引用）。

```js
/**
 * js深拷贝(包括 循环引用 的情况)
 *
 * @param {*} originObj
 * @param {*} [map=new WeakMap()]  使用hash表记录所有的对象的引用关系，初始化为空
 * @returns
 */
function deepClone(originObj, map = new WeakMap()) {
  if (!originObj || typeof originObj !== 'object') return originObj //空或者非对象则返回本身

  //如果这个对象已经被记录则直接返回
  if (map.get(originObj)) {
    return map.get(originObj)
  }
  //这个对象还没有被记录，将其引用记录在map中，进行拷贝
  let result = Array.isArray(originObj) ? [] : {} //拷贝结果
  map.set(originObj, result) //记录引用关系
  let keys = Object.keys(originObj) //originObj的全部key集合
  //拷贝
  for (let i = 0, len = keys.length; i < len; i++) {
    let key = keys[i]
    let temp = originObj[key]
    result[key] = deepClone(temp, map)
  }
  // for (let key of keys) {
  //   result[key] = deepClone(originObj[key], map)
  // }
  return result
}
```

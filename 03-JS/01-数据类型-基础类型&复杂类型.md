# 基础类型&复杂类型

> **参考**
>
> [《JavaScript 数据类型和数据结构》【来源：MDN】](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)
>
> [《javascript 传递参数如果是 object 的话，是按值传递还是按引用传递？》【来源：知乎】](https://www.zhihu.com/question/27114726)

[TOC]

## 动态类型

JavaScript 是一种**弱类型**或者说**动态**语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。

## 数据类型

**7 种基本数据类型：**

- `boolean`
- `null`
- `undefined`
- `number`
- `BigInt`
- `string`
- `symbol`

**1 种复杂数据类型：**

- `Object`
  - `Function`
  - `Array`
  - `Date`
  - `RegExp`
  - `Boolean`
  - `Number`
  - `String`

## 基本类型

### 原始值

**除 Object 以外的所有类型都是不可变的（值本身无法被改变）。**

JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。**我们称这些类型的值为“原始值”。**

#### 布尔类型

布尔表示一个逻辑实体，可以有两个值：

- `true`
- `false`

#### null 类型

null 类型只有一个值：

- `null`

但使用 typeof 检测 null 的类型的时候会返回 `'object'`

```js
typeof null === 'object' // true
```

**null 是唯一一个用 typeof 检测会返回 object 的基本类型值。**

其原因：

> 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。
> 对象的类型标签是 0。
> 由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。
> 曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 `typeof null === 'null'`。

#### undefined 类型

一个没有被赋值的变量会有个默认值：

- `undefined`

#### 数字类型

根据 ECMAScript 标准，JavaScript 中只有一种数字类型：**基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(`2^53` -1) 到 `2^53` -1）**。

它并没有为整数给出一种特定的类型。

除了能够表示浮点数外，还有一些带符号的值：`+Infinity`，`-Infinity` 和 `NaN` (非数值，Not-a-Number)。

数字类型中只有一个整数有两种表示方法： **0 可表示为 `-0` 和 `+0`（"0" 是 +0 的简写）**。 在实践中，这也几乎没有影响。 例如 `+0 === -0` 为真。 但是，你可能要注意除以 0 的时候：

```js
42 / +0 // Infinity
42 / -0 // -Infinity
```

#### BigInt 类型

BigInt 类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。

使用 BigInt，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt 是通过在整数末尾附加 n 或调用构造函数来创建的。

```js
const x = 2n ** 53n // 9007199254740992n
const y = x + 1n // 9007199254740993n
```

可以对 BigInt 使用运算符`+、*、-、**和%`，就像对数字一样。BigInt 严格来说并不等于一个数字，但它是松散的。

在将 BigInt 转换为 Boolean 时，它的行为类似于一个数字：if、||、&&、Boolean 和!。

**BigInt 不能与数字互换操作。否则，将抛出 TypeError。**

#### 字符串类型

JavaScript 的字符串类型用于表示文本数据。**它是一组 16 位的无符号整数值的“元素”。** 在字符串中的每个元素占据了字符串的位置。第一个元素的索引为 0，下一个是索引 1，依此类推。字符串的长度是它的元素的数量。

JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如：

- 获取一个字符串的子串可通过选择个别字母或者使用 `String.substr()`.
- 两个字符串的连接使用连接操作符 (`+`) 或者 `String.concat()`.

**注意代码中的“字符串类型”！**

可以使用字符串来表达复杂的数据。以下是一些很好的性质：

- 容易连接构造复杂的字串符
- 字符串容易被调试(你看到的往往在字符串里)
- 字符串通常是许多 APIs 的常见标准，而且他只能与字符串一同使用。

#### Symbols 符号类型

符号(Symbols)是 ECMAScript 第 6 版新定义的。

符号类型是唯一的并且是不可修改的, 并且也可以用来作为 Object 的 key 的值(如下)。

## 复杂数据类型

## 区别

### 存储地方

原始值：

- 存储在栈（stack）中的简单数据段，也就是说，它们的值存储的是变量的访问位置；

引用值：

- 存储在堆（heap）中，也就是说，**存储在变量处的值是一个指针（point），指向存储对象的内存地址**。
  - 因为引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。
  - 相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

### 访问机制

原始值：

- 可以直接访问到

引用值：

- 在 javascript 中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的**按引用访问**。

### 复制变量时

原始值：

- 在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后**这两个变量是完全独立的，他们只是拥有相同的 value 而已**。

引用值：

- 在将一个保存着对象内存地址的变量复制给另一个变量时，会**把这个内存地址赋值给新变量**，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。
- （这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）**多了一个指针**。

### 参数传递

首先我们应该明确一点：**ECMAScript 中所有函数的参数都是按值来传递的**。

原始值：

- 只是把变量里的值传递给参数，之后参数和这个变量互不影响

引用值：

- **对象变量它里面的值是这个对象在堆内存中的内存地址**，因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。

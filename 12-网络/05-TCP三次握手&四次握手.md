# TCP 三次握手&四次挥手

> **参考**
>
> [《TCP》【来源：MDN】](https://developer.mozilla.org/zh-CN/docs/Glossary/TCP)
>
> [《TCP 的三次握手与四次挥手理解及面试题（很全面）》(作者：青柚\_)【来源：博客园】](https://blog.csdn.net/qq_38950316/article/details/81087809)
>
> [《TCP 三次握手和四次挥手详解(面试常见问题)》(作者：想走安全的小白)【来源：博客园】](https://blog.csdn.net/wwl012345/article/details/90261423)
>
> [《TCP 如何保证传输可靠性》(作者：cbjcry)【来源：CSDN】](https://blog.csdn.net/cbjcry/article/details/84925028)
>
> [《TCP 协议中的三次握手和四次挥手(图解)》(作者：whuslei)【来源：CSDN】](https://blog.csdn.net/whuslei/article/details/6667471)
>
> [《关于 TCP 三次握手和四次挥手，满分回答在此》(作者：飞天小牛肉)【来源：腾讯云社区】](https://cloud.tencent.com/developer/article/1793782)
>
> [《面试官，不要再问我三次握手和四次挥手》(作者：老刘)【来源：知乎】](https://zhuanlan.zhihu.com/p/86426969)
>
> [《面试官问了一下三次握手，我甩出这张脑图，他服了！》(作者：前端劝退师)【来源：前端劝退师】](https://mp.weixin.qq.com/s/RROMAguSYfS9TmT0fxhlgQ)

[TOC]

传输控制协议(TCP)是主要的网络协议之一。它使两台主机能够建立连接并交换数据流。**TCP 能保证数据的交付，维持数据包的发送顺序**。TCP 在 1970 年代被两位 DARPA 的科学家 Vint Cerf 和 Bob Kahn 所设计出来，他们当时被称为互联网之父。

TCP 是互联网的基本通信语言协议。它会校验包的交付。TCP 被用于 Web 浏览器连接到互联网时，从一个地址向另一个地址发送文件传递电子邮件。TCP 确保数据传输的可靠性，并且保证每一个字节在接收时维持它们的发送顺序。操作系统通过一个编程接口来管理 TCP。**TCP 使用三次握手来建立一个连接和四次握手来中断一个连接**。

## 三次握手

![三次握手](https://img-blog.csdnimg.cn/20190516131245842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3bDAxMjM0NQ==,size_16,color_FFFFFF,t_70)

1. 首先，客户机与服务器的 TCP 进程都处于 CLOSED（关闭）状态，当要进行 TCP 连接时，客户机主动打开连接，服务器被动打开连接（这是因为服务请求总是由客户机向服务器发起，因为想要请求的资源都在服务器上，所以客户机想要获取资源就必须主动向服务器发起请求，而不能是等待服务器向自己（客户机）发起请求）。
2. 然后，服务器的 TCP 进程先创建传输控制块 TCB（传输控制块 TCB 存储了每一个连接中的重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号，等等），此时，服务器就处于 LISTEN（收听）状态。同样的，客户机也会首先创建一个传输控制块 TCB 发送给服务器。这样，准备工作就做好了。
3. 现在就可以开始真正的三次握手了。
4. **第一次握手**：首先，客户机先向服务器发送连接请求报文段，该报文段中将首部中的同步位 SYN 置为１（**只有当 SYN 为１时，才能表明客户机想要和服务器建立连接**），并且随机选择一个初始序号 seq 为 ｘ，注意此时的 SYN 数据报中并没有携带数据，但是仍旧要消耗掉一个序号（_意思就是下次客户机发送数据的时候，序号为 x+１_），此时客户机进入到 SYN-SENT（同步已发送）状态。
5. **第二次握手**：此时，服务器收到客户机的请求时，如果同意与该客户机进行连接，则需要向客户机发送确认报文。在发送报文中需要将 SYN 与 ACK 都置为１（**当 ACK 置为 1 时，表明服务器同意与客户机进行连接；同时将 SYN 置为 1，表明服务器想要和客户机建立连接**），并且随机选择一个初始序号 seq 为 y，确认号 ack 为 x+1（_确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了 x，所以下一个序号为 x+1_），注意此时的 SYN 数据报中并没有携带数据，但是也要消耗掉一个序号（_同样的，也就是说服务器下次发送数据的时候，序号为 y+1_），此时 TCP 服务器进程进入到 SYN-RCVD（同步收到）阶段。
6. **第三次握手**：TCP 客户机收到服务器的确认后，还要再向服务器给出确认。确认报文段中 ACK 置为 1，确认号 ack 为 y+1(因为之前服务器给客户机发送的序号为 y，因此现在客户机向服务器发送的确认号为 ack 为 y+1，意思是客户机渴望收到的下一个报文段的第一个数据字节为 y+1)，此时客户机的发送序号 seq 为 x+1（这是因为刚才刚才客户机向服务器发送连接请求时消耗了序号 x，因此此时的序号为 x+1）（**注意：在进行第三次握手时，ACK 报文段可以携带数据，也可以不携带数据，如果携带数据，则消耗一个序列，这样客户机下次发送报文段时的序号为 x+2，如果不携带数据则不消耗序号，下次客户机发送报文段时的序号为 x+1**）。
7. 这时 TCP 连接已经建立，客户机和服务器都进入到 ESTABLISHED（已建立连接）状态。

## 四次挥手

![四次挥手](https://img-blog.csdnimg.cn/201905161747018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3bDAxMjM0NQ==,size_16,color_FFFFFF,t_70)

1. 数据传输结束后，通信的双方都可以释放连接。此时，客户机和服务器都处于 ESTABLISHED（已建立连接）状态。
2. 假设客户机请求完资源了，想要释放连接。
3. **第一次挥手**：首先，客户机的应用进程先向服务器发出连接释放报文段，该报文段中将首部的终止控制位 FIN 置为１（**只有当 FIN 置为１时，才表明客户机想要和服务器断开连接**），并且 seq 序号为ｕ（注意：此时的ｕ不是随机产生的，而是之前客户机传送的数据的最后一个字节的序号加１）。此时客户机进入到 FIN-WAIT-１（终止等待１）状态，等待服务器的确认。
4. **第二次挥手**：服务器收到连接释放报文后发出确认，在发送报文中将首部中的 ACK 置为１（**ACK 置为１，表面服务器同意与客户机释放连接**），并且产生序号 seq 为 ｖ（_注意：此时的 v 不是随机产生的，而是之前服务器传送的数据的最后一个字节的序号加１_），并且发出确认号 ack 为 u+１（_确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前客户机发送了 u，所以下一个序号为 u+1_）。
   1. 此时服务器就进入 CLOSE－WAIT（关闭等待）状态，客户机进入 FIN-WAIT-2（终止等待 2）状态。
   2. 此时，从客户机到服务器这个方向的连接就被释放了，也就是说，客户机已经没有数据要向服务器发送了，但是如果服务器向客户机发送数据，客户机仍要接收数据。
   3. 也就是说：从客户机到服务器的连接已经被释放了，但是从服务器到客户机的连接还没被释放。
   4. 此时，TCP 连接处于半关闭状态。
5. **第三次挥手**：如果服务器向客户机也没有要发送的数据的话，那么服务器的应用进程就可以向客户机发出连接释放报文段（**注意：此时还是服务器向客户机发送数据**），该报文段中将首部的终止控制位 FIN 置为 1（**只有当 FIN 置为１时，才能表明服务器想要和客户机断开连接**），ACK 也置为 1，并且序号 seq 为 w（_注意，此时的 w 不一定等于 v+1。如果在客户机释放了连接之后，服务器向客户机仍旧发送了一部分数据，那么此时 w 不等于 v+1，但是如果期间没有再发送数据，那么 w 就等于 v+1。总而言之，这个 w 等于服务器上一次发送的数据的最后一个字节加 1_），并且发送确认号 ack 为 u+1（_确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前客户机发送了 u，所以下一个序号为 u+1_）。此时服务器就进入了 LAST-ACK（最后确认）状态。
6. **第四次挥手**：客户机收到服务器的连接释放报文后，必须对此报文进行确认。在该报文段中将 ACK 置为 1，确认号 ack 为 w+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了 w，所以下一个序号为 w+1），产生序号 seq 为 u+1（因为上一个发送的数据的序号为 u）。
   1. 此时客户机进入到 TIME-WAIT（等待时间）状态。
   2. 但是，此时 TCP 连接还没有被释放掉。必须经过 **2MSL** 后客户机才能进入到 CLOSED 状态。（**注：MSL 叫做最长报文段寿命，RFC 建议为两分钟，也就是说，要经过四分钟才能进入到 CLOSED 状态**）。

## 问题

### 三次握手中，为什么客户机最后还要再向服务器发送一次确认呢？

这是为了防止已失效的连接请求报文段突然又传到了服务器。所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常的情况，客户机发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户机再重传了一次连接请求，后来收到了确认，建立了连接。数据传输完后，就释放了连接。客户机共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有所谓的“已失效的连接请求报文段”。

但是如果出现了一种异常情况，即客户机发出的第一个报文段并没有丢失，而是在某个节点上长时间滞留了，直至客户机向服务器发送了第二个报文段并且已经完成数据传输释放了连接，此时，第一个报文到达服务器后会被误以为是客户机重新发起的一次连接请求，实质上是一个早已失效的连接请求。如果没有第三次握手，那么这个连接就建立了，但是客户机并不会向服务器发送任何请求，这样连接就会一直持续，白白的消耗网络资源。

### 为什么客户机发送完最后一个数据后要在 TIME-WAIT 状态等待 2MSL（四分钟）的时间呢？

1. **为了保证客户机最后发送的那个 ACK 报文段能够到达服务器**。这个 ACK 报文段可能会丢失。因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN ＋ ACK 报文段的确认。服务器会超时重传这个 FIN ＋ ACK 报文段，而客户机就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段。接着客户机重传一次确认，重新启动 2MSL 计时器，最后客户机和服务器都可以进入到 CLOSED（关闭）状态。如果没有 2MSL 等待时间，那么就无法收到重传的 FIN+ ACK 包，无法进入正常的 CLOSED 状态。
2. **防止“已失效的连接请求报文段”出现在本连接中**。客户机在发送完最后一个 ACK 报文段，再经过时间 2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### TCP 如何保证传输可靠性

- 校验和

发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

- 确认应答+序列号

TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

- 超时重传

当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

- 流量控制

TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。

- 拥塞控制

当网络拥塞时，减少数据的发送。

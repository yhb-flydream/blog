# eventLoop

> **参考**
>
> [《Node 指南》(作者：nodejs.org)【来源：nodejs.org】](https://nodejs.org/zh-cn/docs/guides/)

```text
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

_注意：每个框被称为事件循环机制的一个阶段。_

每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，**当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行**。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，等等。

由于这些操作中的任何一个都可能调度 _更多的_ 操作和由内核排列在轮询阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。

## 定时器

> 本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。

## 待定回调

> 执行延迟到下一个循环迭代的 I/O 回调。

## idle, prepare

> 仅系统内部使用。

## 轮询

> 检索新的 I/O 事件;
> 执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。

## 检测

> setImmediate() 回调函数在这里执行。

## 关闭的回调函数

> 一些关闭的回调函数，如：socket.on('close', ...)。

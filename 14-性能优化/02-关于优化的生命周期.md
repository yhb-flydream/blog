<!--
 * @Author: yaohebin
 * @Date: 2022-04-06 15:03:24
 * @LastEditTime: 2023-11-30 12:41:56
 * @LastEditors: yaohebin
 * @Description: 关于优化的生命周期
-->

# 关于优化的生命周期

[TOC]

## 分析影响的原因及列举需要优化的点

- 为什么要做优化
  - 提升体验
  - 优化资源
- 分析哪些方面需要进行优化
  - 构建结果输出分析
    - 分析打包后，包占用内存的大小
  - 浏览器加载性能分析
- 需要从哪些方面去做优化
  - 资源
    - 代码层面
      - html
      - css
      - js
      - 图片
    - 框架层面
      - vue
        - 客户端渲染
        - 服务端渲染（SSR）
        - 静态站点生成（SSG）
    - 第三方包层面
      - 举例来说：选择 lodash-es 比 lodash 对 tree-shaking 更友好。
    - 打包工具层面
    - 服务端层面
    - 网络层面
  - 体验
    - 更快到达（使用缓存、Server Worker）
    - 使用动画效果（loading 动画、骨架屏）
    - 首屏优化
      - 首屏数据主要内容部分优先加载
      - 图片加载
    - 更新优化
    - 大量数据使用虚拟列表优化
      - [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)

## 在开发到上线的生命周期中对优化进行落实

### 代码时

#### html

- 语义化标签
- table 改为 div + css 布局
- 减少 DOM 节点层级
- 设置图片正确的宽高
- 防止 src 和 link 属性为空
- 正确闭合标签

#### css

- 减少使用 `@import` 外部的 css 文件中使用 @import 会使得页面在加载时增加额外的延迟
- 减少查询层级
- 减少查询范围
- 减少通配符 `*` 或者 `[hidden='true']` 的使用，因为这样需要查找全部的相关元素
- 使用继承
- 属性缩写（比如：`padding: 10px 20px 30px 40px;` 是把 `padding-left`、`padding-top`、`padding-right`、`padding-bottom` 合并到一起了）
- cssSprite 合并雪碧图，减少请求
- 代码重用，提取公共代码
- 合理使用 requestAnimationFrame 动画代替 setTimeout
- 开启 GPU 加速
- 减少回流的操作

#### js

- 避免全局变量
- 慎用闭包
- 使用事件代理，减少代码量
- 避免频繁操作 DOM 节点
- 不使用 `evel()`、`with()`
- 减少对象深层级查找，使用新变量缓存
- 手动进行类型转换
- 三元运算符
- 使用 async 和 defer
- 使用 TS
- 使用 ES6
- 使用字符串模板
- 统一代码风格
- 尽早打破循环
- 使用 **防抖** 和 **节流**
- 使用 **异步** 或 **WebWorker**
- 及时清除引用
- 使用位运算
- 尽量避免在高频事件（如 TouchMove、 Scroll 事件）中修改视图，这会导致多次渲染
- 使用 `===` 代替 `==`，避免产生一些以外错误

#### 图片

- 合适的格式
- 压缩
- 懒加载
- 预加载
- 使用雪碧图
- 使用 iconfont
- 使用 base64 格式
- 使用 css 代替图片
- 使用 CDN
- 响应式图片加载
- 渐进式图片

### 框架时

#### vue

- 开启生产环境模式
- 模板预编译
- 提取组件的 CSS
- 利用 Object.freeze() 冻结一些不必要响应式的数据提升性能
- 扁平化数据结构
- 避免持久化 Store 数据带来的性能问题
- 避免持久化存储的容量持续增长
- 优化无限列表性能
- 通过组件懒加载优化超长应用内容初始渲染性能
- 利用服务端渲染（SSR）和预渲染（Prerender）来优化加载性能
  - 优点：
    - 更好的 SEO
    - 更快的内容到达时间（首屏加载更快）
  - 缺点：
    - 更多的开发条件限制（只支持 beforeCreate 和 created 两个钩子函数）
    - 更多的服务器负载
- 函数型组件
- 子组件拆分
- 局部变量
- v-show，v-if 的分情况使用
- computed 和 watch 区分使用场景
- 使用 keep-alive
- 分批处理
- 非响应式模式
- 仅渲染可视化部分
- 路由懒加载
- 组件库按需引入
- v-for 遍历为 item 添加 key
- 监听事件的及时销毁

### 第三方包层面

- 举例来说：
  - 选择 lodash-es 比 lodash 对 tree-shaking 更友好。
  - 使用 mount 包时可以借助 webpack 缩小包的体积

### 打包时

#### webpack

考虑 **时间** 和 **空间**：

- 分析原因
  - 可视结构
- 减少构建时间
  - 缩减查找范围
  - 缓存副本
  - 定向搜索目标文件
  - 提前构建
  - 多进程并行构建
- 缩小打包体积
  - 分割代码
  - tree-shaking 树摇优化
  - 动态垫片
  - 按需加载
  - 作用提升
  - 压缩资源

##### 开发环境优化

- 缩减搜索范围
  - 配置 include/exclude 缩小 Loader 对文件的搜索范围，好处是避免不必要的转译
  - 配置 resolve、alias 提高文件的搜索速度，好处是定向指定必须文件路径
- 配置缓存
  - 配置 cache 缓存 Loader 对文件的编译副本，好处是再次编译时只编译修改过的文件
- 多线程构建
  - 配置 Thread 将 Loader 单进程转换为多进程，好处是释放 CPU 多核并发的优势
- 使用 source-map
  - 开发环境推荐：cheap-module-eval-source-map；
- 开启 HMR（模块热替换）

##### 生产环境优化

- 构建结果输出分析（webpack-bundle-analyzer）
  - 配置 BundleAnalyzer 分析打包文件结构，好处是找出导致体积过大的原因。从而通过分析原因得出优化方案减少构建时间。
- 多进程打包（thread-loader）
  - 配置 Thread 将 Loader 单进程转换为多进程，好处是释放 CPU 多核并发的优势
- 代码分割
  - 使用 splitChunks 实现代码分割各个模块代码，提取相同部分代码，好处是减少重复代码的出现频率
- 图片压缩（image-webpack-loader）
- 外部扩展(externals)
  - 使用 externals 可以将一些依赖包转换成 CDN 方式引入，减小构建的包体积
- 减少 ES6 转为 ES5 的冗余代码（babel-plugin-transform-runtime）
- Tree Shaking(树摇)
  - 删除项目中未被引用代码，好处是移除重复代码和未使用代码
  - 摇树优化只对 ESM 规范生效，对其他模块规范失效。摇树优化针对静态结构分析，只有 import/export 才能提供静态的导入/导出功能。
- 动态垫片
  - 通过垫片服务根据 UA 返回当前浏览器代码垫片，好处是无需将繁重的代码垫片打包进去
  - @babel/preset-env 提供的 useBuiltIns 可按需导入 Polyfill
- 按需加载
  - 将路由页面/触发性功能单独打包为一个文件，使用时才加载，好处是减轻首屏渲染的负担
- 作用提升
  - 分析模块间依赖关系，把打包好的模块合并到一个函数中，好处是减少函数声明和内存花销
  - 在未开启作用提升前，构建后的代码会存在大量函数闭包。由于模块依赖，通过 webpack 打包后会转换成 IIFE，大量函数闭包包裹代码会导致打包体积增大(模块越多越明显)。在运行代码时创建的函数作用域变多，从而导致更大的内存开销。
- 优化 SourceMap
  - 开发环境推荐：cheap-module-eval-source-map；
  - 生产环境推荐：cheap-module-source-map

#### vite

#### SSR

### 服务端层面

### 网络层面

- 文件大小，数量，尽量减少资源文件的大小和数量（文件合并、代码压缩、开启 GZIP）
- 缓存，针对不经常变动的资源设置缓存，减少请求
- 使用 CDN，加速网络请求
- 使用 HTTP2，能更好的解决对头堵塞，减少网络资源大小
- 服务器端渲染

### 页面加载时（从输入 URL 到页面呈现）

#### URL 解析

#### 查询缓存

##### 强缓存

##### 协商缓存

#### DNS 域名解析

##### DNS 负载均衡

##### DNS 预解析

#### 建立 TCP 连接(三次握手)

#### 发送 HTTP 请求

##### HTTP1、HTTP2、HTTP3

#### 服务器处理请求

#### 返回响应结果

#### 关闭 TCP 连接(四次挥手)

#### 浏览器解析 HTML 并渲染

##### 构建 DOM 树

##### 构建 CSSOM 树

##### 合并渲染树

##### 布局

##### 渲染

#### 关于首屏优化

- 白屏时间：指从输入网址，到页面开始显示内容的时间。
- 首屏时间：指从输入网址，到页面完全渲染的时间。

### 页面更新时

#### 回流

#### 重绘

### 页面卸载时

避免页面卸载后内存泄漏

## 检测最终结果
